{"version":2,"kind":"Notebook","sha256":"4cb21e7f47e9d76a5cd92c3e83e481f7072f1da31ebe0ad88448ddd69a139bc3","slug":"cumulative-surveys","location":"/additional_data/cumulative_surveys.ipynb","dependencies":[],"frontmatter":{"title":"Anostep cumulative survey as completed by each CHP (update daily)","content_includes_title":false,"kernelspec":{"name":"python3","display_name":"Python 3 (ipykernel)","language":"python"},"github":"https://github.com/sanjaynagi/anokin","keywords":["malaria","mosquitoes","population genetics","CKMR","Kenya"],"numbering":{"title":{"offset":1}},"source_url":"https://github.com/sanjaynagi/anokin/blob/main/docs/anostep-site/additional_data/cumulative_surveys.ipynb","edit_url":"https://github.com/sanjaynagi/anokin/edit/main/docs/anostep-site/additional_data/cumulative_surveys.ipynb","exports":[{"format":"ipynb","filename":"cumulative_surveys.ipynb","url":"/cumulative_surveys-75a435b61b26eea63b16ed7aaa1dd770.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":4,"column":1}},"children":[{"type":"text","value":"Here are some quick analyses to look at the data so far :)\nWe start by accessing the data and cleaning it up","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"ZDiKt2X5XU"}],"key":"l4alukaG6H"}],"key":"y3Bzp6QoQM"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import pandas as pd\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nimport numpy as np\nimport json\nimport os\nfrom datetime import datetime, timedelta\n\ndef load_cleaned_data(filename=\"commcare_cleaned_data.csv\"):\n    \"\"\"Load the cleaned data from CSV file\"\"\"\n    try:\n        if not os.path.exists(filename):\n            print(f\"File '{filename}' not found!\")\n            print(\"Please run the data loader script first.\")\n            return None\n        \n        df = pd.read_csv(filename)\n        return df\n    \n    except Exception as e:\n        print(f\"Error loading data: {e}\")\n        return None\n\ndef find_columns(df, column_type):\n    \"\"\"Find columns based on type\"\"\"\n    if column_type == 'username':\n        return [col for col in df.columns if 'username' in col.lower()]\n    elif column_type == 'anoph':\n        return [col for col in df.columns if 'anoph' in col.lower()]\n    elif column_type == 'county':\n        return [col for col in df.columns if 'county' in col.lower()]\n    else:\n        return []\n\ndef create_interactive_username_graph(df):\n    \"\"\"Create interactive username count graph with functional dropdown county filter\"\"\"\n    \n    # Find username, anoph, and county columns\n    username_cols = find_columns(df, 'username')\n    anoph_cols = find_columns(df, 'anoph')\n    county_cols = find_columns(df, 'county')\n    \n    if not username_cols:\n        print(\"No username column found\")\n        return None\n    \n    username_col = username_cols[0]\n    anoph_col = anoph_cols[0] if anoph_cols else None\n    county_col = county_cols[0] if county_cols else None\n    \n    \n    # Filter out 'an_steph_test' and remove rows with missing usernames\n    df_filtered = df[df[username_col] != 'an_steph_test'].copy()\n    df_filtered = df_filtered.dropna(subset=[username_col])\n    df_filtered = df_filtered[df_filtered[username_col] != '']\n    \n    if df_filtered.empty:\n        print(\"No data found after filtering\")\n        return None\n    \n    # Get unique counties\n    unique_counties = []\n    if county_col:\n        unique_counties = sorted(df_filtered[county_col].dropna().unique())\n    \n    # Define colors for different anoph values\n    color_dict = {}\n    if anoph_col:\n        anoph_values = df_filtered[anoph_col].unique()\n        for col in anoph_values:\n            if str(col).lower() == 'yes':\n                color_dict[col] = '#2E8B57'  # Sea Green\n            elif str(col).lower() == 'no':\n                color_dict[col] = '#DC143C'  # Crimson\n            elif str(col) == '___' or str(col) == '---' or str(col).strip() == '' or pd.isna(col):\n                color_dict[col] = '#8B4513'  # Saddle Brown\n            else:\n                color_dict[col] = '#708090'  # Slate Gray\n\n    def create_traces_for_county(county_filter=None):\n        \"\"\"Create traces for specific county or all counties\"\"\"\n        if county_filter and county_col and county_filter != 'all':\n            df_county = df_filtered[df_filtered[county_col] == county_filter]\n        else:\n            df_county = df_filtered\n        \n        if df_county.empty:\n            return [], 0\n        \n        # Get username counts and sort alphabetically\n        df_county = df_county.copy()\n        df_county.loc[:, username_col] = df_county[username_col].astype(str)\n        username_counts = df_county[username_col].value_counts()\n        username_counts = username_counts.reindex(sorted(username_counts.index, key=str))\n        \n        # Create county mapping for each username\n        county_mapping = {}\n        if county_col:\n            for username in username_counts.index:\n                user_counties = df_county[df_county[username_col] == username][county_col].dropna()\n                if not user_counties.empty:\n                    county_mapping[username] = user_counties.mode().iloc[0] if len(user_counties.mode()) > 0 else user_counties.iloc[0]\n                else:\n                    county_mapping[username] = \"Unknown\"\n        \n        traces = []\n        \n        if anoph_col and anoph_col in df_county.columns:\n            # Create stacked bar chart colored by anoph_present\n            crosstab = pd.crosstab(df_county[username_col], df_county[anoph_col], dropna=False)\n            sorted_index = sorted(crosstab.index, key=str)\n            crosstab = crosstab.reindex(sorted_index, fill_value=0)\n            \n            for anoph_value in crosstab.columns:\n                values = crosstab[anoph_value].values\n                \n                # Create hover text\n                hover_text = []\n                for i, (site, count) in enumerate(zip(crosstab.index, values)):\n                    if count > 0:\n                        total_for_site = crosstab.loc[site].sum()\n                        percentage = (count / total_for_site) * 100 if total_for_site > 0 else 0\n                        county_name = county_mapping.get(site, \"Unknown\") if county_mapping else \"N/A\"\n                        hover_text.append(\n                            f\"<b>{site}</b><br>\" +\n                            f\"County: {county_name}<br>\" +\n                            f\"Anoph Present: {anoph_value}<br>\" +\n                            f\"Count: {count}<br>\" +\n                            f\"Percentage: {percentage:.1f}%<br>\" +\n                            f\"Total for site: {total_for_site}\"\n                        )\n                    else:\n                        hover_text.append(\"\")\n                \n                traces.append(go.Bar(\n                    name=f'Anoph: {anoph_value}',\n                    x=crosstab.index,\n                    y=values,\n                    marker_color=color_dict[anoph_value],\n                    marker_line=dict(width=0.5, color='white'),\n                    hovertemplate='%{hovertext}<extra></extra>',\n                    hovertext=hover_text,\n                    opacity=0.8,\n                    visible=True\n                ))\n        else:\n            # Simple bar chart if no anoph data\n            hover_text = []\n            for site, count in zip(username_counts.index, username_counts.values):\n                county_name = county_mapping.get(site, \"Unknown\") if county_mapping else \"N/A\"\n                hover_text.append(\n                    f\"<b>{site}</b><br>\" +\n                    f\"County: {county_name}<br>\" +\n                    f\"Total Surveys: {count}\"\n                )\n            \n            traces.append(go.Bar(\n                x=username_counts.index,\n                y=username_counts.values,\n                marker_color='steelblue',\n                marker_line=dict(width=0.5, color='navy'),\n                hovertemplate='%{hovertext}<extra></extra>',\n                hovertext=hover_text,\n                opacity=0.8,\n                visible=True\n            ))\n        \n        return traces, len(df_county)\n\n    # Create figure with initial data (all counties)\n    fig = go.Figure()\n    \n    # Create separate traces for each county and \"all\"\n    all_data = {}\n    all_traces, all_count = create_traces_for_county()\n    all_data['all'] = {'traces': all_traces, 'count': all_count}\n    \n    county_data = {}\n    for county in unique_counties:\n        county_traces, county_count = create_traces_for_county(county)\n        if county_count > 0:\n            county_data[county] = {'traces': county_traces, 'count': county_count}\n    \n    # Add all traces to figure (initially all visible, others hidden)\n    trace_index = 0\n    all_trace_indices = list(range(len(all_traces)))\n    \n    # Add \"all\" traces\n    for trace in all_traces:\n        trace.visible = True\n        fig.add_trace(trace)\n    trace_index += len(all_traces)\n    \n    # Add county-specific traces (initially hidden)\n    county_trace_indices = {}\n    for county, data in county_data.items():\n        county_trace_indices[county] = list(range(trace_index, trace_index + len(data['traces'])))\n        for trace in data['traces']:\n            trace.visible = False\n            fig.add_trace(trace)\n        trace_index += len(data['traces'])\n    \n    # Create dropdown menu options\n    dropdown_buttons = []\n    \n    # \"All Counties\" option\n    visibility_all = [False] * len(fig.data)\n    for idx in all_trace_indices:\n        visibility_all[idx] = True\n    \n    dropdown_buttons.append(\n        dict(\n            label=f\"All Counties ({all_count:,} surveys)\",\n            method=\"update\",\n            args=[\n                {\"visible\": visibility_all},\n                {\"title\": \"Survey Count by Collection Site<br><sub>All Counties</sub>\"}\n            ]\n        )\n    )\n    \n    # County-specific options\n    for county, data in county_data.items():\n        visibility_county = [False] * len(fig.data)\n        for idx in county_trace_indices[county]:\n            visibility_county[idx] = True\n        \n        dropdown_buttons.append(\n            dict(\n                label=f\"{county} ({data['count']:,} surveys)\",\n                method=\"update\",\n                args=[\n                    {\"visible\": visibility_county},\n                    {\"title\": f\"Survey Count by Collection Site<br><sub>Filtered by {county}</sub>\"}\n                ]\n            )\n        )\n    \n    # Calculate totals for title\n    total_surveys = len(df_filtered)\n    unique_sites = df_filtered[username_col].nunique()\n    unique_counties_count = len(unique_counties) if unique_counties else 0\n    \n    # Add the indicator trace for total surveys in top right\n    fig.add_trace(\n        go.Indicator(\n            mode=\"number\",\n            value=total_surveys,\n            title={\"text\": \"Total Surveys\"},\n            domain={'x': [0.75, 0.95], 'y': [0.88, 1.0]},  # Position at top right\n            number={'font': {'size': 28, 'color': '#2E8B57'}},\n            title_font={'size': 14, 'color': '#333333'}\n        )\n    )\n    \n    title_text = f'Survey Count by Collection Site<br><sub>{unique_sites} sites across {unique_counties_count} counties</sub>'\n    \n    fig.update_layout(\n        title={\n            'text': title_text,\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 16}\n        },\n        xaxis_title='Collection Site',\n        yaxis_title='Count of Survey',\n        barmode='stack' if anoph_col else 'group',\n        hovermode='closest',\n        width=1200,\n        height=700,\n        font=dict(size=12),\n        showlegend=True if anoph_col else False,\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=1,\n            xanchor=\"left\",\n            x=1.02\n        ),\n        margin=dict(l=80, r=120, t=120, b=80),\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        # Add interactive dropdown menu\n        updatemenus=[\n            dict(\n                buttons=dropdown_buttons,\n                direction=\"down\",\n                pad={\"r\": 10, \"t\": 10},\n                showactive=True,\n                x=0.02,\n                xanchor=\"left\",\n                y=1.15,\n                yanchor=\"top\",\n                bgcolor=\"rgba(255,255,255,0.9)\",\n                bordercolor=\"#007bff\",\n                borderwidth=2,\n                font=dict(size=12)\n            ),\n        ]\n    )\n    \n    # Update x-axis\n    fig.update_xaxes(\n        tickangle=45,\n        tickfont=dict(size=10),\n        gridcolor='lightgray',\n        gridwidth=0.5,\n        showgrid=True\n    )\n    \n    # Update y-axis\n    fig.update_yaxes(\n        gridcolor='lightgray',\n        gridwidth=0.5,\n        showgrid=True,\n        zeroline=True,\n        zerolinecolor='gray',\n        zerolinewidth=1\n    )\n    \n    return fig, df_filtered, unique_counties\n\ndef create_summary_dashboard(df):\n    \"\"\"Create a comprehensive dashboard with multiple views\"\"\"\n    \n    username_cols = find_columns(df, 'username')\n    anoph_cols = find_columns(df, 'anoph')\n    \n    if not username_cols:\n        print(\"No username column found for dashboard\")\n        return None\n    \n    username_col = username_cols[0]\n    anoph_col = anoph_cols[0] if anoph_cols else None\n    \n    # Filter data\n    df_filtered = df[df[username_col] != 'an_steph_test'].copy()\n    df_filtered = df_filtered.dropna(subset=[username_col])\n    df_filtered = df_filtered[df_filtered[username_col] != '']\n    \n    if df_filtered.empty:\n        return None\n    \n    # Create subplots\n    fig = make_subplots(\n        rows=2, cols=2,\n        subplot_titles=(\n            'Survey Count by Collection Site',\n            'Anopheles Present Distribution',\n            'Top 10 Most Active Sites',\n            'Survey Activity Overview'\n        ),\n        specs=[[{\"secondary_y\": False}, {\"type\": \"pie\"}],\n               [{\"type\": \"bar\"}, {\"type\": \"indicator\"}]],\n        vertical_spacing=0.12,\n        horizontal_spacing=0.1\n    )\n    \n    # 1. Main bar chart (top left)\n    username_counts = df_filtered[username_col].value_counts()\n    username_counts = username_counts.reindex(sorted(username_counts.index, key=str))\n    \n    if anoph_col and anoph_col in df_filtered.columns:\n        crosstab = pd.crosstab(df_filtered[username_col], df_filtered[anoph_col], dropna=False)\n        sorted_index = sorted(crosstab.index, key=str)\n        crosstab = crosstab.reindex(sorted_index, fill_value=0)\n        \n        colors = ['#2E8B57', '#DC143C', '#8B4513', '#708090']\n        for i, anoph_value in enumerate(crosstab.columns):\n            color = colors[i % len(colors)]\n            fig.add_trace(\n                go.Bar(\n                    name=f'Anoph: {anoph_value}',\n                    x=crosstab.index,\n                    y=crosstab[anoph_value].values,\n                    marker_color=color,\n                    showlegend=True\n                ),\n                row=1, col=1\n            )\n    \n    # 2. Pie chart (top right)\n    if anoph_col and anoph_col in df_filtered.columns:\n        anoph_counts = df_filtered[anoph_col].value_counts()\n        fig.add_trace(\n            go.Pie(\n                labels=anoph_counts.index,\n                values=anoph_counts.values,\n                marker_colors=['#2E8B57', '#DC143C', '#8B4513', '#708090'][:len(anoph_counts)],\n                hovertemplate='<b>%{label}</b><br>Count: %{value}<br>Percentage: %{percent}<extra></extra>'\n            ),\n            row=1, col=2\n        )\n    \n    # 3. Top 10 sites (bottom left)\n    top_10_sites = username_counts.head(10)\n    fig.add_trace(\n        go.Bar(\n            x=top_10_sites.values,\n            y=top_10_sites.index,\n            orientation='h',\n            marker_color='lightblue',\n            marker_line=dict(width=1, color='navy'),\n            showlegend=False,\n            hovertemplate='<b>%{y}</b><br>Surveys: %{x}<extra></extra>'\n        ),\n        row=2, col=1\n    )\n    \n    # 4. Summary indicators (bottom right)\n    total_surveys = len(df_filtered)\n    unique_sites = len(username_counts)\n    avg_per_site = total_surveys / unique_sites if unique_sites > 0 else 0\n    \n    fig.add_trace(\n        go.Indicator(\n            mode=\"number+delta\",\n            value=total_surveys,\n            title={\"text\": \"Total Surveys\"},\n            domain={'x': [0, 0.5], 'y': [0.7, 1]},\n            number={'font': {'size': 40}},\n            delta={'reference': total_surveys * 0.9, 'relative': True}\n        ),\n        row=2, col=2\n    )\n    \n    # Update layout\n    fig.update_layout(\n        title={\n            'text': 'CommCare Survey Dashboard',\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 20}\n        },\n        height=600,\n        width=800,\n        showlegend=True,\n        barmode='stack'\n    )\n    \n    return fig\n\ndef main():\n    try:\n        # Load the cleaned data\n        df = load_cleaned_data()\n        if df is None:\n            return\n        \n        # Create interactive graph with county dropdown\n        result = create_interactive_username_graph(df)\n        \n        if result is not None:\n            if len(result) == 3:\n                fig, df_filtered, unique_counties = result\n                fig.show()\n            else:\n                return\n    \n    except Exception as e:\n        pass\n\nif __name__ == \"__main__\":\n    main()","key":"daC6KVhdzM"},{"type":"output","id":"Ii2AaJwa2x5acqxMDZTel","data":[{"output_type":"display_data","metadata":{},"data":{"application/vnd.plotly.v1+json":{"content_type":"application/vnd.plotly.v1+json","hash":"69c3edd796a82cd50122a536b2615b95","path":"/69c3edd796a82cd50122a536b2615b95.json"},"text/html":{"content_type":"text/html","hash":"2f4f6faff5706e0f4b0ccd7f7a44e345","path":"/2f4f6faff5706e0f4b0ccd7f7a44e345.html"}}}],"key":"zwOmUUFKsf"}],"key":"UXdlrraZHV"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Great work team!üëè üëè üëè","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"kfk30hH3Jb"}],"identifier":"great-work-team","label":"Great work team!üëè üëè üëè","html_id":"great-work-team","implicit":true,"key":"CTRVO2bEPU"}],"key":"FLAYJ1nI71"}],"key":"WxabPTK6ww"},"references":{"cite":{"order":[],"data":{}}}}