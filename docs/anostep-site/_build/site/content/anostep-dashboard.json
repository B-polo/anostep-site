{"version":2,"kind":"Notebook","sha256":"63590ce8d0637516ab6600992eb0745c15851373255242b742287e816e5a0f5b","slug":"anostep-dashboard","location":"/notebooks/Anostep_dashboard.ipynb","dependencies":[],"frontmatter":{"title":"AnoSTEP results so far","content_includes_title":false,"kernelspec":{"name":"python3","display_name":"Python 3 (ipykernel)","language":"python"},"github":"https://github.com/sanjaynagi/anokin","keywords":["malaria","mosquitoes","population genetics","CKMR","Kenya"],"numbering":{"title":{"offset":1}},"source_url":"https://github.com/sanjaynagi/anokin/blob/master/docs/anostep-site/notebooks/Anostep_dashboard.ipynb","edit_url":"https://github.com/sanjaynagi/anokin/edit/master/docs/anostep-site/notebooks/Anostep_dashboard.ipynb","exports":[{"format":"ipynb","filename":"Anostep_dashboard.ipynb","url":"/Anostep_dashboard-be3e7e65cef30f4e38b180ef34790d19.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Here are some quick analyses to look at the data","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"uRNmXjxEjP"}],"key":"m77jD9XH7Y"}],"key":"KNlnr2faq3"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"import pandas as pd\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nimport numpy as np\nimport json\nimport os\nfrom datetime import datetime, timedelta\n\ndef load_cleaned_data(filename=\"commcare_cleaned_data.csv\"):\n    \"\"\"Load the cleaned data from CSV file\"\"\"\n    try:\n        if not os.path.exists(filename):\n            print(f\"File '{filename}' not found!\")\n            print(\"Please run the data loader script first.\")\n            return None\n        \n        df = pd.read_csv(filename)\n        return df\n    \n    except Exception as e:\n        print(f\"Error loading data: {e}\")\n        return None\n\ndef find_columns(df, column_type):\n    \"\"\"Find columns based on type\"\"\"\n    if column_type == 'username':\n        return [col for col in df.columns if 'username' in col.lower()]\n    elif column_type == 'anoph':\n        return [col for col in df.columns if 'anoph' in col.lower()]\n    elif column_type == 'county':\n        return [col for col in df.columns if 'county' in col.lower()]\n    else:\n        return []\n\ndef create_interactive_username_graph(df):\n    \"\"\"Create interactive username count graph with functional dropdown county filter\"\"\"\n    \n    # Find username, anoph, and county columns\n    username_cols = find_columns(df, 'username')\n    anoph_cols = find_columns(df, 'anoph')\n    county_cols = find_columns(df, 'county')\n    \n    if not username_cols:\n        print(\"No username column found\")\n        return None\n    \n    username_col = username_cols[0]\n    anoph_col = anoph_cols[0] if anoph_cols else None\n    county_col = county_cols[0] if county_cols else None\n    \n    \n    # Filter out 'an_steph_test' and remove rows with missing usernames\n    df_filtered = df[df[username_col] != 'an_steph_test'].copy()\n    df_filtered = df_filtered.dropna(subset=[username_col])\n    df_filtered = df_filtered[df_filtered[username_col] != '']\n    \n    if df_filtered.empty:\n        print(\"No data found after filtering\")\n        return None\n    \n    # Get unique counties\n    unique_counties = []\n    if county_col:\n        unique_counties = sorted(df_filtered[county_col].dropna().unique())\n    \n    # Define colors for different anoph values\n    color_dict = {}\n    if anoph_col:\n        anoph_values = df_filtered[anoph_col].unique()\n        for col in anoph_values:\n            if str(col).lower() == 'yes':\n                color_dict[col] = '#2E8B57'  # Sea Green\n            elif str(col).lower() == 'no':\n                color_dict[col] = '#DC143C'  # Crimson\n            elif str(col) == '___' or str(col) == '---' or str(col).strip() == '' or pd.isna(col):\n                color_dict[col] = '#8B4513'  # Saddle Brown\n            else:\n                color_dict[col] = '#708090'  # Slate Gray\n\n    def create_traces_for_county(county_filter=None):\n        \"\"\"Create traces for specific county or all counties\"\"\"\n        if county_filter and county_col and county_filter != 'all':\n            df_county = df_filtered[df_filtered[county_col] == county_filter]\n        else:\n            df_county = df_filtered\n        \n        if df_county.empty:\n            return [], 0\n        \n        # Get username counts and sort alphabetically\n        df_county = df_county.copy()\n        df_county.loc[:, username_col] = df_county[username_col].astype(str)\n        username_counts = df_county[username_col].value_counts()\n        username_counts = username_counts.reindex(sorted(username_counts.index, key=str))\n        \n        # Create county mapping for each username\n        county_mapping = {}\n        if county_col:\n            for username in username_counts.index:\n                user_counties = df_county[df_county[username_col] == username][county_col].dropna()\n                if not user_counties.empty:\n                    county_mapping[username] = user_counties.mode().iloc[0] if len(user_counties.mode()) > 0 else user_counties.iloc[0]\n                else:\n                    county_mapping[username] = \"Unknown\"\n        \n        traces = []\n        \n        if anoph_col and anoph_col in df_county.columns:\n            # Create stacked bar chart colored by anoph_present\n            crosstab = pd.crosstab(df_county[username_col], df_county[anoph_col], dropna=False)\n            sorted_index = sorted(crosstab.index, key=str)\n            crosstab = crosstab.reindex(sorted_index, fill_value=0)\n            \n            for anoph_value in crosstab.columns:\n                values = crosstab[anoph_value].values\n                \n                # Create hover text\n                hover_text = []\n                for i, (site, count) in enumerate(zip(crosstab.index, values)):\n                    if count > 0:\n                        total_for_site = crosstab.loc[site].sum()\n                        percentage = (count / total_for_site) * 100 if total_for_site > 0 else 0\n                        county_name = county_mapping.get(site, \"Unknown\") if county_mapping else \"N/A\"\n                        hover_text.append(\n                            f\"<b>{site}</b><br>\" +\n                            f\"County: {county_name}<br>\" +\n                            f\"Anoph Present: {anoph_value}<br>\" +\n                            f\"Count: {count}<br>\" +\n                            f\"Percentage: {percentage:.1f}%<br>\" +\n                            f\"Total for site: {total_for_site}\"\n                        )\n                    else:\n                        hover_text.append(\"\")\n                \n                traces.append(go.Bar(\n                    name=f'Anoph: {anoph_value}',\n                    x=crosstab.index,\n                    y=values,\n                    marker_color=color_dict[anoph_value],\n                    marker_line=dict(width=0.5, color='white'),\n                    hovertemplate='%{hovertext}<extra></extra>',\n                    hovertext=hover_text,\n                    opacity=0.8,\n                    visible=True\n                ))\n        else:\n            # Simple bar chart if no anoph data\n            hover_text = []\n            for site, count in zip(username_counts.index, username_counts.values):\n                county_name = county_mapping.get(site, \"Unknown\") if county_mapping else \"N/A\"\n                hover_text.append(\n                    f\"<b>{site}</b><br>\" +\n                    f\"County: {county_name}<br>\" +\n                    f\"Total Surveys: {count}\"\n                )\n            \n            traces.append(go.Bar(\n                x=username_counts.index,\n                y=username_counts.values,\n                marker_color='steelblue',\n                marker_line=dict(width=0.5, color='navy'),\n                hovertemplate='%{hovertext}<extra></extra>',\n                hovertext=hover_text,\n                opacity=0.8,\n                visible=True\n            ))\n        \n        return traces, len(df_county)\n\n    # Create figure with initial data (all counties)\n    fig = go.Figure()\n    \n    # Create separate traces for each county and \"all\"\n    all_data = {}\n    all_traces, all_count = create_traces_for_county()\n    all_data['all'] = {'traces': all_traces, 'count': all_count}\n    \n    county_data = {}\n    for county in unique_counties:\n        county_traces, county_count = create_traces_for_county(county)\n        if county_count > 0:\n            county_data[county] = {'traces': county_traces, 'count': county_count}\n    \n    # Add all traces to figure (initially all visible, others hidden)\n    trace_index = 0\n    all_trace_indices = list(range(len(all_traces)))\n    \n    # Add \"all\" traces\n    for trace in all_traces:\n        trace.visible = True\n        fig.add_trace(trace)\n    trace_index += len(all_traces)\n    \n    # Add county-specific traces (initially hidden)\n    county_trace_indices = {}\n    for county, data in county_data.items():\n        county_trace_indices[county] = list(range(trace_index, trace_index + len(data['traces'])))\n        for trace in data['traces']:\n            trace.visible = False\n            fig.add_trace(trace)\n        trace_index += len(data['traces'])\n    \n    # Create dropdown menu options\n    dropdown_buttons = []\n    \n    # \"All Counties\" option\n    visibility_all = [False] * len(fig.data)\n    for idx in all_trace_indices:\n        visibility_all[idx] = True\n    \n    dropdown_buttons.append(\n        dict(\n            label=f\"All Counties ({all_count:,} surveys)\",\n            method=\"update\",\n            args=[\n                {\"visible\": visibility_all},\n                {\"title\": \"Survey Count by Collection Site<br><sub>All Counties</sub>\"}\n            ]\n        )\n    )\n    \n    # County-specific options\n    for county, data in county_data.items():\n        visibility_county = [False] * len(fig.data)\n        for idx in county_trace_indices[county]:\n            visibility_county[idx] = True\n        \n        dropdown_buttons.append(\n            dict(\n                label=f\"{county} ({data['count']:,} surveys)\",\n                method=\"update\",\n                args=[\n                    {\"visible\": visibility_county},\n                    {\"title\": f\"Survey Count by Collection Site<br><sub>Filtered by {county}</sub>\"}\n                ]\n            )\n        )\n    \n    # Calculate totals for title\n    total_surveys = len(df_filtered)\n    unique_sites = df_filtered[username_col].nunique()\n    unique_counties_count = len(unique_counties) if unique_counties else 0\n    \n    # Add the indicator trace for total surveys in top right\n    fig.add_trace(\n        go.Indicator(\n            mode=\"number\",\n            value=total_surveys,\n            title={\"text\": \"Total Surveys\"},\n            domain={'x': [0.75, 0.95], 'y': [0.88, 1.0]},  # Position at top right\n            number={'font': {'size': 28, 'color': '#2E8B57'}},\n            title_font={'size': 14, 'color': '#333333'}\n        )\n    )\n    \n    title_text = f'Survey Count by Collection Site<br><sub>{unique_sites} sites across {unique_counties_count} counties</sub>'\n    \n    fig.update_layout(\n        title={\n            'text': title_text,\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 16}\n        },\n        xaxis_title='Collection Site',\n        yaxis_title='Count of Survey',\n        barmode='stack' if anoph_col else 'group',\n        hovermode='closest',\n        width=1200,\n        height=700,\n        font=dict(size=12),\n        showlegend=True if anoph_col else False,\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=1,\n            xanchor=\"left\",\n            x=1.02\n        ),\n        margin=dict(l=80, r=120, t=120, b=80),\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        # Add interactive dropdown menu\n        updatemenus=[\n            dict(\n                buttons=dropdown_buttons,\n                direction=\"down\",\n                pad={\"r\": 10, \"t\": 10},\n                showactive=True,\n                x=0.02,\n                xanchor=\"left\",\n                y=1.15,\n                yanchor=\"top\",\n                bgcolor=\"rgba(255,255,255,0.9)\",\n                bordercolor=\"#007bff\",\n                borderwidth=2,\n                font=dict(size=12)\n            ),\n        ]\n    )\n    \n    # Update x-axis\n    fig.update_xaxes(\n        tickangle=45,\n        tickfont=dict(size=10),\n        gridcolor='lightgray',\n        gridwidth=0.5,\n        showgrid=True\n    )\n    \n    # Update y-axis\n    fig.update_yaxes(\n        gridcolor='lightgray',\n        gridwidth=0.5,\n        showgrid=True,\n        zeroline=True,\n        zerolinecolor='gray',\n        zerolinewidth=1\n    )\n    \n    return fig, df_filtered, unique_counties\n\ndef create_summary_dashboard(df):\n    \"\"\"Create a comprehensive dashboard with multiple views\"\"\"\n    \n    username_cols = find_columns(df, 'username')\n    anoph_cols = find_columns(df, 'anoph')\n    \n    if not username_cols:\n        print(\"No username column found for dashboard\")\n        return None\n    \n    username_col = username_cols[0]\n    anoph_col = anoph_cols[0] if anoph_cols else None\n    \n    # Filter data\n    df_filtered = df[df[username_col] != 'an_steph_test'].copy()\n    df_filtered = df_filtered.dropna(subset=[username_col])\n    df_filtered = df_filtered[df_filtered[username_col] != '']\n    \n    if df_filtered.empty:\n        return None\n    \n    # Create subplots\n    fig = make_subplots(\n        rows=2, cols=2,\n        subplot_titles=(\n            'Survey Count by Collection Site',\n            'Anopheles Present Distribution',\n            'Top 10 Most Active Sites',\n            'Survey Activity Overview'\n        ),\n        specs=[[{\"secondary_y\": False}, {\"type\": \"pie\"}],\n               [{\"type\": \"bar\"}, {\"type\": \"indicator\"}]],\n        vertical_spacing=0.12,\n        horizontal_spacing=0.1\n    )\n    \n\ndef main():\n    try:\n        # Load the cleaned data\n        df = load_cleaned_data()\n        if df is None:\n            return\n        \n        # Create interactive graph with county dropdown\n        result = create_interactive_username_graph(df)\n        \n        if result is not None:\n            if len(result) == 3:\n                fig, df_filtered, unique_counties = result\n                fig.show()\n            else:\n                return\n    \n    except Exception as e:\n        pass\n\nif __name__ == \"__main__\":\n    main()","visibility":"remove","key":"fKucvlmSNu"},{"type":"output","id":"jLbcpTSC9K4VmvEnPRttL","data":[{"output_type":"display_data","metadata":{},"data":{"application/vnd.plotly.v1+json":{"content_type":"application/vnd.plotly.v1+json","hash":"69c3edd796a82cd50122a536b2615b95","path":"/69c3edd796a82cd50122a536b2615b95.json"},"text/html":{"content_type":"text/html","hash":"a7f10a1d7fd01b295377cee684ce3cda","path":"/a7f10a1d7fd01b295377cee684ce3cda.html"}}}],"visibility":"show","key":"Lu22pCq4cM"}],"visibility":"show","key":"qhSr6UWU04"},{"type":"block","kind":"notebook-content","children":[{"type":"code","lang":"","value":"Here are the larval samples collected by the CHPs with an iteractive weekly timeline.","key":"yLUit9cBq3"}],"key":"kmlkuWdVyS"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"import pandas as pd\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nimport numpy as np\nimport json\nimport os\nfrom datetime import datetime, timedelta\n\ndef load_cleaned_data(filename=\"commcare_cleaned_data.csv\"):\n    \"\"\"Load the cleaned data from CSV file\"\"\"\n    try:\n        if not os.path.exists(filename):\n            return None\n        \n        df = pd.read_csv(filename)\n        return df\n    \n    except Exception as e:\n        return None\n\ndef find_columns(df, column_type):\n    \"\"\"Find columns based on type\"\"\"\n    if column_type == 'username':\n        return [col for col in df.columns if 'username' in col.lower()]\n    elif column_type == 'anoph':\n        return [col for col in df.columns if 'anoph' in col.lower()]\n    elif column_type == 'county':\n        return [col for col in df.columns if 'county' in col.lower()]\n    elif column_type == 'date':\n        return [col for col in df.columns if 'collection_date' in col.lower() or 'date' in col.lower()]\n    else:\n        return []\n\ndef prepare_time_data(df):\n    \"\"\"Prepare data with time information\"\"\"\n    \n    # Find date column\n    date_cols = find_columns(df, 'date')\n    if not date_cols:\n        return df, None\n    \n    date_col = date_cols[0]\n    \n    # Convert to datetime\n    df_time = df.copy()\n    df_time[date_col] = pd.to_datetime(df_time[date_col], errors='coerce')\n    \n    # Remove rows with invalid dates\n    df_time = df_time.dropna(subset=[date_col])\n    \n    if df_time.empty:\n        return df, None\n    \n    # Add week information\n    df_time['week_number'] = df_time[date_col].dt.isocalendar().week\n    df_time['year'] = df_time[date_col].dt.year\n    df_time['year_week'] = df_time[date_col].dt.strftime('%Y-W%U')\n    df_time['week_start'] = df_time[date_col].dt.to_period('W').dt.start_time\n    \n    return df_time, date_col\n\ndef create_interactive_time_slider_graph(df):\n    \"\"\"Create interactive graph with time slider for collection weeks\"\"\"\n    \n    # Find required columns\n    username_cols = find_columns(df, 'username')\n    anoph_cols = find_columns(df, 'anoph')\n    county_cols = find_columns(df, 'county')\n    \n    if not username_cols:\n        return None\n    \n    username_col = username_cols[0]\n    anoph_col = anoph_cols[0] if anoph_cols else None\n    county_col = county_cols[0] if county_cols else None\n    \n    # Prepare time data\n    df_time, date_col = prepare_time_data(df)\n    if date_col is None:\n        return None\n    \n    # Filter out test user\n    df_filtered = df_time[df_time[username_col] != 'an_steph_test'].copy()\n    df_filtered = df_filtered.dropna(subset=[username_col])\n    df_filtered = df_filtered[df_filtered[username_col] != '']\n    \n    if df_filtered.empty:\n        return None\n    \n    # Get unique weeks sorted\n    unique_weeks = sorted(df_filtered['year_week'].unique())\n    unique_counties = sorted(df_filtered[county_col].dropna().unique()) if county_col else []\n    \n    # Create frames for animation/slider\n    frames = []\n    \n    # Color mapping for anoph values\n    color_dict = {}\n    if anoph_col:\n        anoph_values = df_filtered[anoph_col].unique()\n        for col in anoph_values:\n            if str(col).lower() == 'yes':\n                color_dict[col] = '#2E8B57'  # Sea Green\n            elif str(col).lower() == 'no':\n                color_dict[col] = '#DC143C'  # Crimson\n            elif str(col) == '___' or str(col) == '---' or str(col).strip() == '' or pd.isna(col):\n                color_dict[col] = '#8B4513'  # Saddle Brown\n            else:\n                color_dict[col] = '#708090'  # Slate Gray\n    \n    # Create data for each week\n    for week in unique_weeks:\n        week_data = df_filtered[df_filtered['year_week'] == week]\n        \n        if week_data.empty:\n            continue\n        \n        frame_traces = []\n        \n        if anoph_col and anoph_col in week_data.columns:\n            # Create stacked bar chart for this week\n            username_counts = week_data[username_col].value_counts()\n            username_counts = username_counts.reindex(sorted(username_counts.index, key=str))\n            \n            crosstab = pd.crosstab(week_data[username_col], week_data[anoph_col], dropna=False)\n            sorted_index = sorted(crosstab.index, key=str)\n            crosstab = crosstab.reindex(sorted_index, fill_value=0)\n            \n            # County mapping for this week\n            county_mapping = {}\n            if county_col:\n                for username in crosstab.index:\n                    user_counties = week_data[week_data[username_col] == username][county_col].dropna()\n                    if not user_counties.empty:\n                        county_mapping[username] = user_counties.mode().iloc[0] if len(user_counties.mode()) > 0 else user_counties.iloc[0]\n                    else:\n                        county_mapping[username] = \"Unknown\"\n            \n            for anoph_value in crosstab.columns:\n                values = crosstab[anoph_value].values\n                \n                # Create hover text for this week\n                hover_text = []\n                for site, count in zip(crosstab.index, values):\n                    if count > 0:\n                        total_for_site = crosstab.loc[site].sum()\n                        percentage = (count / total_for_site) * 100 if total_for_site > 0 else 0\n                        county_name = county_mapping.get(site, \"Unknown\") if county_mapping else \"N/A\"\n                        hover_text.append(\n                            f\"<b>{site}</b><br>\" +\n                            f\"Week: {week}<br>\" +\n                            f\"County: {county_name}<br>\" +\n                            f\"Anoph Present: {anoph_value}<br>\" +\n                            f\"Count: {count}<br>\" +\n                            f\"Percentage: {percentage:.1f}%<br>\" +\n                            f\"Total for site: {total_for_site}\"\n                        )\n                    else:\n                        hover_text.append(\"\")\n                \n                frame_traces.append(go.Bar(\n                    name=f'Anoph: {anoph_value}',\n                    x=crosstab.index,\n                    y=values,\n                    marker_color=color_dict[anoph_value],\n                    marker_line=dict(width=0.5, color='white'),\n                    hovertemplate='%{hovertext}<extra></extra>',\n                    hovertext=hover_text,\n                    opacity=0.8\n                ))\n        else:\n            # Simple bar chart for this week\n            username_counts = week_data[username_col].value_counts()\n            username_counts = username_counts.reindex(sorted(username_counts.index, key=str))\n            \n            # County mapping for this week\n            county_mapping = {}\n            if county_col:\n                for username in username_counts.index:\n                    user_counties = week_data[week_data[username_col] == username][county_col].dropna()\n                    if not user_counties.empty:\n                        county_mapping[username] = user_counties.mode().iloc[0] if len(user_counties.mode()) > 0 else user_counties.iloc[0]\n                    else:\n                        county_mapping[username] = \"Unknown\"\n            \n            hover_text = []\n            for site, count in zip(username_counts.index, username_counts.values):\n                county_name = county_mapping.get(site, \"Unknown\") if county_mapping else \"N/A\"\n                hover_text.append(\n                    f\"<b>{site}</b><br>\" +\n                    f\"Week: {week}<br>\" +\n                    f\"County: {county_name}<br>\" +\n                    f\"Total Surveys: {count}\"\n                )\n            \n            frame_traces.append(go.Bar(\n                x=username_counts.index,\n                y=username_counts.values,\n                marker_color='steelblue',\n                marker_line=dict(width=0.5, color='navy'),\n                hovertemplate='%{hovertext}<extra></extra>',\n                hovertext=hover_text,\n                opacity=0.8\n            ))\n        \n        frames.append(go.Frame(\n            data=frame_traces,\n            name=week,\n            layout=go.Layout(\n                title=f'Survey Count by Collection Site - Week {week}<br><sub>Total: {len(week_data):,} surveys</sub>'\n            )\n        ))\n    \n    # Create initial figure (first week)\n    if frames:\n        fig = go.Figure(data=frames[0].data, frames=frames)\n    else:\n        return None\n    \n    # Update layout with slider\n    total_surveys = len(df_filtered)\n    unique_sites = df_filtered[username_col].nunique()\n    unique_counties_count = len(unique_counties)\n    \n    fig.update_layout(\n        title={\n            'text': f'Survey Count by Collection Site - Interactive Timeline<br><sub>Total: {total_surveys:,} surveys from {unique_sites} sites across {unique_counties_count} counties</sub>',\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 16}\n        },\n        xaxis_title='Collection Site',\n        yaxis_title='Count of Survey',\n        barmode='stack' if anoph_col else 'group',\n        hovermode='closest',\n        width=700,\n        height=600,\n        font=dict(size=12),\n        showlegend=True if anoph_col else False,\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=1,\n            xanchor=\"left\",\n            x=1.02\n        ),\n        margin=dict(l=80, r=120, t=120, b=150),\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        updatemenus=[\n            dict(\n                type=\"buttons\",\n                direction=\"left\",\n                buttons=list([\n                    dict(\n                        args=[{\"frame\": {\"duration\": 500, \"redraw\": True},\n                               \"fromcurrent\": True, \"transition\": {\"duration\": 300}}],\n                        label=\"Play\",\n                        method=\"animate\"\n                    ),\n                    dict(\n                        args=[{\"frame\": {\"duration\": 0, \"redraw\": True},\n                               \"mode\": \"immediate\",\n                               \"transition\": {\"duration\": 0}}],\n                        label=\"Pause\",\n                        method=\"animate\"\n                    )\n                ]),\n                pad={\"r\": 10, \"t\": 87},\n                showactive=False,\n                x=0.011,\n                xanchor=\"right\",\n                y=0,\n                yanchor=\"top\"\n            ),\n        ],\n        sliders=[\n            dict(\n                active=0,\n                yanchor=\"top\",\n                xanchor=\"left\",\n                currentvalue={\n                    \"font\": {\"size\": 16},\n                    \"prefix\": \"Week: \",\n                    \"visible\": True,\n                    \"xanchor\": \"right\"\n                },\n                transition={\"duration\": 300, \"easing\": \"cubic-in-out\"},\n                pad={\"b\": 10, \"t\": 50},\n                len=0.9,\n                x=0.1,\n                y=0,\n                steps=[\n                    dict(\n                        args=[\n                            [week],\n                            {\"frame\": {\"duration\": 300, \"redraw\": True},\n                             \"mode\": \"immediate\",\n                             \"transition\": {\"duration\": 300}}\n                        ],\n                        label=week,\n                        method=\"animate\"\n                    ) for week in unique_weeks\n                ]\n            )\n        ]\n    )\n    \n    # Update axes\n    fig.update_xaxes(\n        tickangle=45,\n        tickfont=dict(size=10),\n        gridcolor='lightgray',\n        gridwidth=0.5,\n        showgrid=True\n    )\n    \n    fig.update_yaxes(\n        gridcolor='lightgray',\n        gridwidth=0.5,\n        showgrid=True,\n        zeroline=True,\n        zerolinecolor='gray',\n        zerolinewidth=1\n    )\n    \n    return fig\n\ndef main():\n    try:\n        df = load_cleaned_data()\n        if df is None:\n            return\n        \n        fig = create_interactive_time_slider_graph(df)\n        \n        if fig is not None:\n            fig.show()\n    \n    except Exception as e:\n        pass\n\nif __name__ == \"__main__\":\n    main()","visibility":"remove","key":"VwDUYQK3IG"},{"type":"output","id":"yAvOyQNERciXX2qVKvaMF","data":[{"output_type":"display_data","metadata":{},"data":{"application/vnd.plotly.v1+json":{"content_type":"application/vnd.plotly.v1+json","hash":"fd27dbc797aaa76284b9f1b063e4e1ce","path":"/fd27dbc797aaa76284b9f1b063e4e1ce.json"},"text/html":{"content_type":"text/html","hash":"2c539af619fa1df8fdc8a9a9a107b92b","path":"/2c539af619fa1df8fdc8a9a9a107b92b.html"}}}],"visibility":"show","key":"lqYOYSNnLu"}],"visibility":"show","key":"oBHPYVqnkW"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"How many total mosquitoes from each species?","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"RBByopMSo6"}],"key":"dHENNFzTEJ"}],"key":"vDHZ2TcY5n"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Plotting species catch by date","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"tG90G6x3n4"}],"identifier":"plotting-species-catch-by-date","label":"Plotting species catch by date","html_id":"plotting-species-catch-by-date","implicit":true,"key":"Bz18HmJI0v"}],"key":"RNDA2e7xKN"},{"type":"block","kind":"notebook-code","data":{"tags":[]},"children":[{"type":"code","lang":"python","executable":true,"value":"import pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport numpy as np\nfrom math import cos, radians\n\n# Load both datasets with error handling\ntry:\n    df_commcare = pd.read_csv('commcare_data.csv')\n    df_priority = pd.read_csv('KenyaAdapt2025.csv')\nexcept FileNotFoundError as e:\n    print(f\"Error loading files: {e}\")\n    exit()\n\n# Rename Priority column to GP (Geographic Priority)\ndf_priority = df_priority.rename(columns={'Priority': 'GP'})\n\n# Clean the CommCare data with error handling\nrequired_columns = [\n    'gps_coordinates_latitude_(degrees)', \n    'gps_coordinates_longitude_(degrees)', \n    'type_of_breeding_site',\n    'collection_date'\n]\n\n# Check if required columns exist\nmissing_columns = [col for col in required_columns if col not in df_commcare.columns]\nif missing_columns:\n    print(f\"Missing required columns: {missing_columns}\")\n    exit()\n\n# Clean the data\ndf_clean = df_commcare.dropna(subset=required_columns)\ndf_clean = df_clean[df_clean['type_of_breeding_site'] != '---']\n\n# Create the grouped counts for CommCare data\ntry:\n    df_counts = df_clean.groupby([\n        'gps_coordinates_latitude_(degrees)', \n        'gps_coordinates_longitude_(degrees)', \n        'type_of_breeding_site', \n        'collection_date'\n    ]).agg({\n        'case_case_id': 'count',\n        'county': 'first',\n        'subcounty': 'first',\n        'geographical_information_village_name': 'first'\n    }).reset_index()\nexcept KeyError as e:\n    print(f\"Error in grouping data: {e}\")\n    exit()\n\n# Rename columns to match original structure\ndf_counts = df_counts.rename(columns={\n    'gps_coordinates_latitude_(degrees)': 'latitude',\n    'gps_coordinates_longitude_(degrees)': 'longitude', \n    'type_of_breeding_site': 'type',\n    'collection_date': 'Date',\n    'case_case_id': 'morph_id'\n})\n\n# Get unique GP values\nunique_gps = sorted(df_priority['GP'].unique())\n\n# Function to create circle coordinates for buffer zones\ndef create_circle(center_lat, center_lon, radius_km, num_points=50):\n    \"\"\"Create circle coordinates for buffer zones\"\"\"\n    try:\n        lat_radius = radius_km / 111.0\n        lon_radius = radius_km / (111.0 * cos(radians(center_lat)))\n        \n        angles = np.linspace(0, 2*np.pi, num_points)\n        circle_lats = center_lat + lat_radius * np.cos(angles)\n        circle_lons = center_lon + lon_radius * np.sin(angles)\n        \n        return circle_lats, circle_lons\n    except Exception:\n        return [], []\n\n# Calculate map center\ntry:\n    all_lats = list(df_counts['latitude']) + list(df_priority['lat'])\n    all_lons = list(df_counts['longitude']) + list(df_priority['long'])\n    center_lat = np.mean([lat for lat in all_lats if not np.isnan(lat)])\n    center_lon = np.mean([lon for lon in all_lons if not np.isnan(lon)])\nexcept Exception:\n    center_lat, center_lon = 0.5, 37.0  # Default Kenya center\n\n# Create the figure\nfig = go.Figure()\n\n# Add all breeding sites with conditional coloring based on anoph_present\nmarker_sizes = np.clip(df_counts['morph_id'] * 3, 5, 20)\n\n# Create color array based on anoph_present status\ncolors = []\nfor _, row in df_counts.iterrows():\n    # Get the original row data to check anoph_present\n    original_data = df_clean[\n        (df_clean['gps_coordinates_latitude_(degrees)'] == row['latitude']) &\n        (df_clean['gps_coordinates_longitude_(degrees)'] == row['longitude']) &\n        (df_clean['type_of_breeding_site'] == row['type']) &\n        (df_clean['collection_date'] == row['Date'])\n    ]\n    \n    if len(original_data) > 0:\n        anoph_status = original_data['anoph_present'].iloc[0]\n        if anoph_status == 'yes':\n            colors.append('rgba(50, 200, 50, 0.8)')  # Green for anoph present\n        elif anoph_status == 'no':\n            colors.append('rgba(255, 50, 50, 0.8)')  # Red for anoph not present\n        else:\n            colors.append('rgba(128, 128, 128, 0.7)')  # Gray for unknown/missing\n    else:\n        colors.append('rgba(128, 128, 128, 0.7)')  # Gray for unknown\n\nfig.add_trace(go.Scattermapbox(\n    lat=df_counts['latitude'],\n    lon=df_counts['longitude'],\n    mode='markers',\n    marker=dict(\n        size=marker_sizes,\n        sizemin=5,\n        color=colors,  # Use conditional coloring\n        opacity=0.8\n    ),\n    name='Breeding Sites',\n    text=[f\"<b>{site_type}</b><br>\" +\n          f\"Count: {count}<br>\" +\n          f\"Date: {date}<br>\" +\n          f\"Anopheles: {anoph}<br>\" +\n          f\"County: {county}<br>\" +\n          f\"Village: {village}<br>\" +\n          f\"Coords: ({lat:.4f}, {lon:.4f})\"\n          for site_type, count, date, county, village, lat, lon, anoph in \n          zip(df_counts['type'], df_counts['morph_id'], df_counts['Date'], \n              df_counts['county'].fillna('N/A'), \n              df_counts['geographical_information_village_name'].fillna('N/A'),\n              df_counts['latitude'], df_counts['longitude'],\n              [df_clean[(df_clean['gps_coordinates_latitude_(degrees)'] == row['latitude']) &\n                       (df_clean['gps_coordinates_longitude_(degrees)'] == row['longitude']) &\n                       (df_clean['type_of_breeding_site'] == row['type']) &\n                       (df_clean['collection_date'] == row['Date'])]['anoph_present'].iloc[0] \n               if len(df_clean[(df_clean['gps_coordinates_latitude_(degrees)'] == row['latitude']) &\n                              (df_clean['gps_coordinates_longitude_(degrees)'] == row['longitude']) &\n                              (df_clean['type_of_breeding_site'] == row['type']) &\n                              (df_clean['collection_date'] == row['Date'])]) > 0 else 'Unknown'\n               for _, row in df_counts.iterrows()])],\n    hovertemplate='%{text}<extra></extra>',\n    legendgroup='breeding',\n    showlegend=False\n))\n\n# Create traces for each GP individually with enhanced visibility\npriority_colors = px.colors.sequential.Plasma  # Better contrast on satellite imagery\n\n# Add traces for \"All GPs\" view (initially visible)\nfor i, gp in enumerate(unique_gps):\n    gp_data = df_priority[df_priority['GP'] == gp]\n    if len(gp_data) == 0:\n        continue\n        \n    color_idx = int(i * (len(priority_colors) - 1) / max(1, (len(unique_gps) - 1)))\n    \n    # GP points with enhanced visibility for satellite view\n    fig.add_trace(go.Scattermapbox(\n        lat=gp_data['lat'],\n        lon=gp_data['long'],\n        mode='markers',\n        marker=dict(\n            size=16,  # Larger size for better visibility\n            color=priority_colors[color_idx],  # Use the priority color directly\n            symbol='circle',  # Circle symbols for better visibility\n            opacity=1.0  # Full opacity\n        ),\n        name=f'GP {gp}',\n        text=[f\"<b>GP {gp}</b><br>\" +\n              f\"GoogleID: {gid}<br>\" +\n              f\"Coords: ({lat:.4f}, {lon:.4f})\"\n              for gid, lat, lon in \n              zip(gp_data['GoogleID'], gp_data['lat'], gp_data['long'])],\n        hovertemplate='%{text}<extra></extra>',\n        legendgroup=f'gp_{gp}',\n        visible=True,\n        showlegend=False\n    ))\n    \n    # 1km buffer for this GP with better visibility on satellite\n    for _, row in gp_data.iterrows():\n        circle_lats, circle_lons = create_circle(row['lat'], row['long'], 1)\n        if len(circle_lats) > 0:  # Only add if circle was created successfully\n            fig.add_trace(go.Scattermapbox(\n                lat=circle_lats,\n                lon=circle_lons,\n                mode='lines',\n                line=dict(width=3, color='rgba(255, 255, 0, 1.0)'),  # Yellow for visibility\n                fill='toself',\n                fillcolor='rgba(255, 255, 0, 0.15)',\n                name='1km Buffer' if i == 0 and row['GP'] == unique_gps[0] else '',\n                showlegend=True if i == 0 and row['GP'] == unique_gps[0] else False,\n                hoverinfo='skip',\n                legendgroup='buffer_1km',\n                visible=True\n            ))\n    \n    # 2km buffer for this GP with better visibility on satellite\n    for _, row in gp_data.iterrows():\n        circle_lats, circle_lons = create_circle(row['lat'], row['long'], 2)\n        if len(circle_lats) > 0:  # Only add if circle was created successfully\n            fig.add_trace(go.Scattermapbox(\n                lat=circle_lats,\n                lon=circle_lons,\n                mode='lines',\n                line=dict(width=3, color='rgba(255, 0, 255, 1.0)'),  # Magenta for visibility\n                fill='toself',\n                fillcolor='rgba(255, 0, 255, 0.15)',\n                name='2km Buffer' if i == 0 and row['GP'] == unique_gps[0] else '',\n                showlegend=True if i == 0 and row['GP'] == unique_gps[0] else False,\n                hoverinfo='skip',\n                legendgroup='buffer_2km',\n                visible=True\n            ))\n\n# Create dropdown buttons with zoom functionality\ndropdown_buttons = []\n\n# Calculate total number of traces for visibility arrays\ntotal_traces = 1  # Breeding sites\nfor gp in unique_gps:\n    gp_count = len(df_priority[df_priority['GP'] == gp])\n    total_traces += 1 + (2 * gp_count)  # GP points + buffer traces\n\n# \"All\" option - shows all GPs and resets to full view\nall_visibility = [True] * total_traces\n\ndropdown_buttons.append(\n    dict(\n        label=\"All GPs\",\n        method=\"update\",\n        args=[\n            {\"visible\": all_visibility},\n            {\n                \"mapbox.center.lat\": center_lat,\n                \"mapbox.center.lon\": center_lon,\n                \"mapbox.zoom\": 6\n            }\n        ]\n    )\n)\n\n# Individual GP options with zoom to selected location\ntrace_idx = 1  # Start after breeding sites trace\nfor target_gp in unique_gps:\n    visibility = [True]  # Breeding sites always visible\n    \n    # Get coordinates for this GP to zoom to\n    gp_coords = df_priority[df_priority['GP'] == target_gp]\n    if len(gp_coords) > 0:\n        gp_center_lat = gp_coords['lat'].mean()\n        gp_center_lon = gp_coords['long'].mean()\n    else:\n        gp_center_lat, gp_center_lon = center_lat, center_lon\n    \n    # Calculate visibility for all traces\n    current_trace_idx = 1\n    for gp in unique_gps:\n        gp_count = len(df_priority[df_priority['GP'] == gp])\n        if gp == target_gp:\n            visibility.extend([True] * (1 + 2 * gp_count))  # Show this GP + buffers\n        else:\n            visibility.extend([False] * (1 + 2 * gp_count))  # Hide other GPs + buffers\n        current_trace_idx += 1 + 2 * gp_count\n    \n    dropdown_buttons.append(\n        dict(\n            label=f\"GP {target_gp}\",\n            method=\"update\",\n            args=[\n                {\"visible\": visibility},\n                {\n                    \"mapbox.center.lat\": gp_center_lat,\n                    \"mapbox.center.lon\": gp_center_lon,\n                    \"mapbox.zoom\": 13.5  # Increased zoom to better fit 2km buffer\n                }\n            ]\n        )\n    )\n\n# Update layout with dropdown\nfig.update_layout(\n    mapbox=dict(\n        style='open-street-map',  # Changed to open-street-map (no token required)\n        center=dict(lat=center_lat, lon=center_lon),\n        zoom=6\n    ),\n    title=dict(\n        text=\"Interactive Anopheles Breeding Sites & GP Locations with Buffer Zones\",\n        x=0.5,\n        font=dict(size=16)\n    ),\n    height=700,\n    margin=dict(t=80, b=20, l=20, r=20),\n    legend=dict(\n        yanchor=\"top\",\n        y=0.99,\n        xanchor=\"right\",\n        x=0.99,\n        bgcolor=\"rgba(255,255,255,0.8)\"\n    ),\n    updatemenus=[\n        dict(\n            buttons=dropdown_buttons,\n            direction=\"down\",\n            showactive=True,\n            x=0.02,\n            xanchor=\"left\",\n            y=0.95,\n            yanchor=\"top\",\n            bgcolor=\"rgba(255,255,255,0.9)\",\n            bordercolor=\"rgba(0,0,0,0.3)\",\n            font=dict(size=12)\n        )\n    ]\n)\n\n# Add annotation for dropdown\nfig.add_annotation(\n    text=\"Select GP:\",\n    xref=\"paper\", yref=\"paper\",\n    x=0.02, y=0.97,\n    xanchor=\"left\", yanchor=\"bottom\",\n    showarrow=False,\n    font=dict(size=12, color=\"black\"),\n    bgcolor=\"rgba(255,255,255,0.8)\"\n)\n\n# Display the map\nfig.show()\n\n# # Save as HTML file\n# fig.write_html(\"interactive_commcare_gp_map.html\")","visibility":"remove","key":"hjxzXPwcwp"},{"type":"output","id":"r3CII03aJA0qP2CiTWM6s","data":[{"name":"stderr","output_type":"stream","text":"/var/folders/n1/1nywbmb90132hcqjkb1q3ngw0000gn/T/ipykernel_2608/2941327099.py:118: DeprecationWarning:\n\n*scattermapbox* is deprecated! Use *scattermap* instead. Learn more at: https://plotly.com/python/mapbox-to-maplibre/\n\n/var/folders/n1/1nywbmb90132hcqjkb1q3ngw0000gn/T/ipykernel_2608/2941327099.py:167: DeprecationWarning:\n\n*scattermapbox* is deprecated! Use *scattermap* instead. Learn more at: https://plotly.com/python/mapbox-to-maplibre/\n\n/var/folders/n1/1nywbmb90132hcqjkb1q3ngw0000gn/T/ipykernel_2608/2941327099.py:193: DeprecationWarning:\n\n*scattermapbox* is deprecated! Use *scattermap* instead. Learn more at: https://plotly.com/python/mapbox-to-maplibre/\n\n/var/folders/n1/1nywbmb90132hcqjkb1q3ngw0000gn/T/ipykernel_2608/2941327099.py:211: DeprecationWarning:\n\n*scattermapbox* is deprecated! Use *scattermap* instead. Learn more at: https://plotly.com/python/mapbox-to-maplibre/\n\n"},{"output_type":"display_data","metadata":{},"data":{"application/vnd.plotly.v1+json":{"content_type":"application/vnd.plotly.v1+json","hash":"e8856af2a7af4ba94cbcaa367812166b","path":"/e8856af2a7af4ba94cbcaa367812166b.json"},"text/html":{"content_type":"text/html","hash":"e46bac6436982d150bbc87a321dfbb63","path":"/e46bac6436982d150bbc87a321dfbb63.html"}}}],"visibility":"show","key":"ggz1o6LIms"}],"visibility":"show","key":"lx6XtT808K"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Great work team!👏 👏 👏","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"LhBCU3ZnnB"}],"identifier":"great-work-team","label":"Great work team!👏 👏 👏","html_id":"great-work-team","implicit":true,"key":"zWz1lkE3N8"}],"key":"sbfEs55FtQ"}],"key":"YEV7MmzslS"},"references":{"cite":{"order":[],"data":{}}}}