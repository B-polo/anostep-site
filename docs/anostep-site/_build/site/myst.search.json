{"version":"1","records":[{"hierarchy":{"lvl1":"Brian Polo"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Brian Polo"},"content":"Welcome to my first project website!\n\nThe AnoSTEP larval collection is a key component of the AnoSTEP-Afrika Project, a collaborative, multi-country initiative led by the Ifakara Health Institute. The primary goal of the project is to understand the distribution, behavior, and public health impact of the invasive malaria vector, Anopheles stephensi, across various ecological zones in Africa.\n\nThe larval collection specifically involves:\n\nTraining field teams: Scientists and field teams are trained to identify Anopheles stephensi habitats, collect and sort mosquito larvae, and enter the data into electronic forms.\n\nHabitat characterization: The collection efforts focus on identifying and characterizing the types of water bodies where Anopheles stephensi larvae are found. This includes assessing factors like water sources, vegetation, and other environmental conditions.\n\nData-driven surveillance: By collecting larvae from various sites, the project aims to establish a robust surveillance system to track the spread of Anopheles stephensi and understand its bionomics (life cycle and habits) in new African settings.\n\nThis larval collection is crucial for developing targeted and effective control strategies against this emerging threat to malaria control, particularly in urban and peri-urban areas where the vector thrives. The data gathered helps to inform national and regional strategies and builds local capacity to respond to the growing challenge.\n\nThe training slides are located \n\nhere","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"AnoSTEP results so far"},"type":"lvl1","url":"/anostep-dashboard","position":0},{"hierarchy":{"lvl1":"AnoSTEP results so far"},"content":"Here are some quick analyses to look at the data\n\nimport pandas as pd\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nimport numpy as np\nimport json\nimport os\nfrom datetime import datetime, timedelta\n\ndef load_cleaned_data(filename=\"commcare_cleaned_data.csv\"):\n    \"\"\"Load the cleaned data from CSV file\"\"\"\n    try:\n        if not os.path.exists(filename):\n            print(f\"File '{filename}' not found!\")\n            print(\"Please run the data loader script first.\")\n            return None\n        \n        df = pd.read_csv(filename)\n        return df\n    \n    except Exception as e:\n        print(f\"Error loading data: {e}\")\n        return None\n\ndef find_columns(df, column_type):\n    \"\"\"Find columns based on type\"\"\"\n    if column_type == 'username':\n        return [col for col in df.columns if 'username' in col.lower()]\n    elif column_type == 'anoph':\n        return [col for col in df.columns if 'anoph' in col.lower()]\n    elif column_type == 'county':\n        return [col for col in df.columns if 'county' in col.lower()]\n    else:\n        return []\n\ndef create_interactive_username_graph(df):\n    \"\"\"Create interactive username count graph with functional dropdown county filter\"\"\"\n    \n    # Find username, anoph, and county columns\n    username_cols = find_columns(df, 'username')\n    anoph_cols = find_columns(df, 'anoph')\n    county_cols = find_columns(df, 'county')\n    \n    if not username_cols:\n        print(\"No username column found\")\n        return None\n    \n    username_col = username_cols[0]\n    anoph_col = anoph_cols[0] if anoph_cols else None\n    county_col = county_cols[0] if county_cols else None\n    \n    \n    # Filter out 'an_steph_test' and remove rows with missing usernames\n    df_filtered = df[df[username_col] != 'an_steph_test'].copy()\n    df_filtered = df_filtered.dropna(subset=[username_col])\n    df_filtered = df_filtered[df_filtered[username_col] != '']\n    \n    if df_filtered.empty:\n        print(\"No data found after filtering\")\n        return None\n    \n    # Get unique counties\n    unique_counties = []\n    if county_col:\n        unique_counties = sorted(df_filtered[county_col].dropna().unique())\n    \n    # Define colors for different anoph values\n    color_dict = {}\n    if anoph_col:\n        anoph_values = df_filtered[anoph_col].unique()\n        for col in anoph_values:\n            if str(col).lower() == 'yes':\n                color_dict[col] = '#2E8B57'  # Sea Green\n            elif str(col).lower() == 'no':\n                color_dict[col] = '#DC143C'  # Crimson\n            elif str(col) == '___' or str(col) == '---' or str(col).strip() == '' or pd.isna(col):\n                color_dict[col] = '#8B4513'  # Saddle Brown\n            else:\n                color_dict[col] = '#708090'  # Slate Gray\n\n    def create_traces_for_county(county_filter=None):\n        \"\"\"Create traces for specific county or all counties\"\"\"\n        if county_filter and county_col and county_filter != 'all':\n            df_county = df_filtered[df_filtered[county_col] == county_filter]\n        else:\n            df_county = df_filtered\n        \n        if df_county.empty:\n            return [], 0\n        \n        # Get username counts and sort alphabetically\n        df_county = df_county.copy()\n        df_county.loc[:, username_col] = df_county[username_col].astype(str)\n        username_counts = df_county[username_col].value_counts()\n        username_counts = username_counts.reindex(sorted(username_counts.index, key=str))\n        \n        # Create county mapping for each username\n        county_mapping = {}\n        if county_col:\n            for username in username_counts.index:\n                user_counties = df_county[df_county[username_col] == username][county_col].dropna()\n                if not user_counties.empty:\n                    county_mapping[username] = user_counties.mode().iloc[0] if len(user_counties.mode()) > 0 else user_counties.iloc[0]\n                else:\n                    county_mapping[username] = \"Unknown\"\n        \n        traces = []\n        \n        if anoph_col and anoph_col in df_county.columns:\n            # Create stacked bar chart colored by anoph_present\n            crosstab = pd.crosstab(df_county[username_col], df_county[anoph_col], dropna=False)\n            sorted_index = sorted(crosstab.index, key=str)\n            crosstab = crosstab.reindex(sorted_index, fill_value=0)\n            \n            for anoph_value in crosstab.columns:\n                values = crosstab[anoph_value].values\n                \n                # Create hover text\n                hover_text = []\n                for i, (site, count) in enumerate(zip(crosstab.index, values)):\n                    if count > 0:\n                        total_for_site = crosstab.loc[site].sum()\n                        percentage = (count / total_for_site) * 100 if total_for_site > 0 else 0\n                        county_name = county_mapping.get(site, \"Unknown\") if county_mapping else \"N/A\"\n                        hover_text.append(\n                            f\"<b>{site}</b><br>\" +\n                            f\"County: {county_name}<br>\" +\n                            f\"Anoph Present: {anoph_value}<br>\" +\n                            f\"Count: {count}<br>\" +\n                            f\"Percentage: {percentage:.1f}%<br>\" +\n                            f\"Total for site: {total_for_site}\"\n                        )\n                    else:\n                        hover_text.append(\"\")\n                \n                traces.append(go.Bar(\n                    name=f'Anoph: {anoph_value}',\n                    x=crosstab.index,\n                    y=values,\n                    marker_color=color_dict[anoph_value],\n                    marker_line=dict(width=0.5, color='white'),\n                    hovertemplate='%{hovertext}<extra></extra>',\n                    hovertext=hover_text,\n                    opacity=0.8,\n                    visible=True\n                ))\n        else:\n            # Simple bar chart if no anoph data\n            hover_text = []\n            for site, count in zip(username_counts.index, username_counts.values):\n                county_name = county_mapping.get(site, \"Unknown\") if county_mapping else \"N/A\"\n                hover_text.append(\n                    f\"<b>{site}</b><br>\" +\n                    f\"County: {county_name}<br>\" +\n                    f\"Total Surveys: {count}\"\n                )\n            \n            traces.append(go.Bar(\n                x=username_counts.index,\n                y=username_counts.values,\n                marker_color='steelblue',\n                marker_line=dict(width=0.5, color='navy'),\n                hovertemplate='%{hovertext}<extra></extra>',\n                hovertext=hover_text,\n                opacity=0.8,\n                visible=True\n            ))\n        \n        return traces, len(df_county)\n\n    # Create figure with initial data (all counties)\n    fig = go.Figure()\n    \n    # Create separate traces for each county and \"all\"\n    all_data = {}\n    all_traces, all_count = create_traces_for_county()\n    all_data['all'] = {'traces': all_traces, 'count': all_count}\n    \n    county_data = {}\n    for county in unique_counties:\n        county_traces, county_count = create_traces_for_county(county)\n        if county_count > 0:\n            county_data[county] = {'traces': county_traces, 'count': county_count}\n    \n    # Add all traces to figure (initially all visible, others hidden)\n    trace_index = 0\n    all_trace_indices = list(range(len(all_traces)))\n    \n    # Add \"all\" traces\n    for trace in all_traces:\n        trace.visible = True\n        fig.add_trace(trace)\n    trace_index += len(all_traces)\n    \n    # Add county-specific traces (initially hidden)\n    county_trace_indices = {}\n    for county, data in county_data.items():\n        county_trace_indices[county] = list(range(trace_index, trace_index + len(data['traces'])))\n        for trace in data['traces']:\n            trace.visible = False\n            fig.add_trace(trace)\n        trace_index += len(data['traces'])\n    \n    # Create dropdown menu options\n    dropdown_buttons = []\n    \n    # \"All Counties\" option\n    visibility_all = [False] * len(fig.data)\n    for idx in all_trace_indices:\n        visibility_all[idx] = True\n    \n    dropdown_buttons.append(\n        dict(\n            label=f\"All Counties ({all_count:,} surveys)\",\n            method=\"update\",\n            args=[\n                {\"visible\": visibility_all},\n                {\"title\": \"Survey Count by Collection Site<br><sub>All Counties</sub>\"}\n            ]\n        )\n    )\n    \n    # County-specific options\n    for county, data in county_data.items():\n        visibility_county = [False] * len(fig.data)\n        for idx in county_trace_indices[county]:\n            visibility_county[idx] = True\n        \n        dropdown_buttons.append(\n            dict(\n                label=f\"{county} ({data['count']:,} surveys)\",\n                method=\"update\",\n                args=[\n                    {\"visible\": visibility_county},\n                    {\"title\": f\"Survey Count by Collection Site<br><sub>Filtered by {county}</sub>\"}\n                ]\n            )\n        )\n    \n    # Calculate totals for title\n    total_surveys = len(df_filtered)\n    unique_sites = df_filtered[username_col].nunique()\n    unique_counties_count = len(unique_counties) if unique_counties else 0\n    \n    # Add the indicator trace for total surveys in top right\n    fig.add_trace(\n        go.Indicator(\n            mode=\"number\",\n            value=total_surveys,\n            title={\"text\": \"Total Surveys\"},\n            domain={'x': [0.75, 0.95], 'y': [0.88, 1.0]},  # Position at top right\n            number={'font': {'size': 28, 'color': '#2E8B57'}},\n            title_font={'size': 14, 'color': '#333333'}\n        )\n    )\n    \n    title_text = f'Survey Count by Collection Site<br><sub>{unique_sites} sites across {unique_counties_count} counties</sub>'\n    \n    fig.update_layout(\n        title={\n            'text': title_text,\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 16}\n        },\n        xaxis_title='Collection Site',\n        yaxis_title='Count of Survey',\n        barmode='stack' if anoph_col else 'group',\n        hovermode='closest',\n        width=1200,\n        height=700,\n        font=dict(size=12),\n        showlegend=True if anoph_col else False,\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=1,\n            xanchor=\"left\",\n            x=1.02\n        ),\n        margin=dict(l=80, r=120, t=120, b=80),\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        # Add interactive dropdown menu\n        updatemenus=[\n            dict(\n                buttons=dropdown_buttons,\n                direction=\"down\",\n                pad={\"r\": 10, \"t\": 10},\n                showactive=True,\n                x=0.02,\n                xanchor=\"left\",\n                y=1.15,\n                yanchor=\"top\",\n                bgcolor=\"rgba(255,255,255,0.9)\",\n                bordercolor=\"#007bff\",\n                borderwidth=2,\n                font=dict(size=12)\n            ),\n        ]\n    )\n    \n    # Update x-axis\n    fig.update_xaxes(\n        tickangle=45,\n        tickfont=dict(size=10),\n        gridcolor='lightgray',\n        gridwidth=0.5,\n        showgrid=True\n    )\n    \n    # Update y-axis\n    fig.update_yaxes(\n        gridcolor='lightgray',\n        gridwidth=0.5,\n        showgrid=True,\n        zeroline=True,\n        zerolinecolor='gray',\n        zerolinewidth=1\n    )\n    \n    return fig, df_filtered, unique_counties\n\ndef create_summary_dashboard(df):\n    \"\"\"Create a comprehensive dashboard with multiple views\"\"\"\n    \n    username_cols = find_columns(df, 'username')\n    anoph_cols = find_columns(df, 'anoph')\n    \n    if not username_cols:\n        print(\"No username column found for dashboard\")\n        return None\n    \n    username_col = username_cols[0]\n    anoph_col = anoph_cols[0] if anoph_cols else None\n    \n    # Filter data\n    df_filtered = df[df[username_col] != 'an_steph_test'].copy()\n    df_filtered = df_filtered.dropna(subset=[username_col])\n    df_filtered = df_filtered[df_filtered[username_col] != '']\n    \n    if df_filtered.empty:\n        return None\n    \n    # Create subplots\n    fig = make_subplots(\n        rows=2, cols=2,\n        subplot_titles=(\n            'Survey Count by Collection Site',\n            'Anopheles Present Distribution',\n            'Top 10 Most Active Sites',\n            'Survey Activity Overview'\n        ),\n        specs=[[{\"secondary_y\": False}, {\"type\": \"pie\"}],\n               [{\"type\": \"bar\"}, {\"type\": \"indicator\"}]],\n        vertical_spacing=0.12,\n        horizontal_spacing=0.1\n    )\n    \n\ndef main():\n    try:\n        # Load the cleaned data\n        df = load_cleaned_data()\n        if df is None:\n            return\n        \n        # Create interactive graph with county dropdown\n        result = create_interactive_username_graph(df)\n        \n        if result is not None:\n            if len(result) == 3:\n                fig, df_filtered, unique_counties = result\n                fig.show()\n            else:\n                return\n    \n    except Exception as e:\n        pass\n\nif __name__ == \"__main__\":\n    main()\n\nHere are the larval samples collected by the CHPs with an iteractive weekly timeline.\n\nimport pandas as pd\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nimport numpy as np\nimport json\nimport os\nfrom datetime import datetime, timedelta\n\ndef load_cleaned_data(filename=\"commcare_cleaned_data.csv\"):\n    \"\"\"Load the cleaned data from CSV file\"\"\"\n    try:\n        if not os.path.exists(filename):\n            return None\n        \n        df = pd.read_csv(filename)\n        return df\n    \n    except Exception as e:\n        return None\n\ndef find_columns(df, column_type):\n    \"\"\"Find columns based on type\"\"\"\n    if column_type == 'username':\n        return [col for col in df.columns if 'username' in col.lower()]\n    elif column_type == 'anoph':\n        return [col for col in df.columns if 'anoph' in col.lower()]\n    elif column_type == 'county':\n        return [col for col in df.columns if 'county' in col.lower()]\n    elif column_type == 'date':\n        return [col for col in df.columns if 'collection_date' in col.lower() or 'date' in col.lower()]\n    else:\n        return []\n\ndef prepare_time_data(df):\n    \"\"\"Prepare data with time information\"\"\"\n    \n    # Find date column\n    date_cols = find_columns(df, 'date')\n    if not date_cols:\n        return df, None\n    \n    date_col = date_cols[0]\n    \n    # Convert to datetime\n    df_time = df.copy()\n    df_time[date_col] = pd.to_datetime(df_time[date_col], errors='coerce')\n    \n    # Remove rows with invalid dates\n    df_time = df_time.dropna(subset=[date_col])\n    \n    if df_time.empty:\n        return df, None\n    \n    # Add week information\n    df_time['week_number'] = df_time[date_col].dt.isocalendar().week\n    df_time['year'] = df_time[date_col].dt.year\n    df_time['year_week'] = df_time[date_col].dt.strftime('%Y-W%U')\n    df_time['week_start'] = df_time[date_col].dt.to_period('W').dt.start_time\n    \n    return df_time, date_col\n\ndef create_interactive_time_slider_graph(df):\n    \"\"\"Create interactive graph with time slider for collection weeks\"\"\"\n    \n    # Find required columns\n    username_cols = find_columns(df, 'username')\n    anoph_cols = find_columns(df, 'anoph')\n    county_cols = find_columns(df, 'county')\n    \n    if not username_cols:\n        return None\n    \n    username_col = username_cols[0]\n    anoph_col = anoph_cols[0] if anoph_cols else None\n    county_col = county_cols[0] if county_cols else None\n    \n    # Prepare time data\n    df_time, date_col = prepare_time_data(df)\n    if date_col is None:\n        return None\n    \n    # Filter out test user\n    df_filtered = df_time[df_time[username_col] != 'an_steph_test'].copy()\n    df_filtered = df_filtered.dropna(subset=[username_col])\n    df_filtered = df_filtered[df_filtered[username_col] != '']\n    \n    if df_filtered.empty:\n        return None\n    \n    # Get unique weeks sorted\n    unique_weeks = sorted(df_filtered['year_week'].unique())\n    unique_counties = sorted(df_filtered[county_col].dropna().unique()) if county_col else []\n    \n    # Create frames for animation/slider\n    frames = []\n    \n    # Color mapping for anoph values\n    color_dict = {}\n    if anoph_col:\n        anoph_values = df_filtered[anoph_col].unique()\n        for col in anoph_values:\n            if str(col).lower() == 'yes':\n                color_dict[col] = '#2E8B57'  # Sea Green\n            elif str(col).lower() == 'no':\n                color_dict[col] = '#DC143C'  # Crimson\n            elif str(col) == '___' or str(col) == '---' or str(col).strip() == '' or pd.isna(col):\n                color_dict[col] = '#8B4513'  # Saddle Brown\n            else:\n                color_dict[col] = '#708090'  # Slate Gray\n    \n    # Create data for each week\n    for week in unique_weeks:\n        week_data = df_filtered[df_filtered['year_week'] == week]\n        \n        if week_data.empty:\n            continue\n        \n        frame_traces = []\n        \n        if anoph_col and anoph_col in week_data.columns:\n            # Create stacked bar chart for this week\n            username_counts = week_data[username_col].value_counts()\n            username_counts = username_counts.reindex(sorted(username_counts.index, key=str))\n            \n            crosstab = pd.crosstab(week_data[username_col], week_data[anoph_col], dropna=False)\n            sorted_index = sorted(crosstab.index, key=str)\n            crosstab = crosstab.reindex(sorted_index, fill_value=0)\n            \n            # County mapping for this week\n            county_mapping = {}\n            if county_col:\n                for username in crosstab.index:\n                    user_counties = week_data[week_data[username_col] == username][county_col].dropna()\n                    if not user_counties.empty:\n                        county_mapping[username] = user_counties.mode().iloc[0] if len(user_counties.mode()) > 0 else user_counties.iloc[0]\n                    else:\n                        county_mapping[username] = \"Unknown\"\n            \n            for anoph_value in crosstab.columns:\n                values = crosstab[anoph_value].values\n                \n                # Create hover text for this week\n                hover_text = []\n                for site, count in zip(crosstab.index, values):\n                    if count > 0:\n                        total_for_site = crosstab.loc[site].sum()\n                        percentage = (count / total_for_site) * 100 if total_for_site > 0 else 0\n                        county_name = county_mapping.get(site, \"Unknown\") if county_mapping else \"N/A\"\n                        hover_text.append(\n                            f\"<b>{site}</b><br>\" +\n                            f\"Week: {week}<br>\" +\n                            f\"County: {county_name}<br>\" +\n                            f\"Anoph Present: {anoph_value}<br>\" +\n                            f\"Count: {count}<br>\" +\n                            f\"Percentage: {percentage:.1f}%<br>\" +\n                            f\"Total for site: {total_for_site}\"\n                        )\n                    else:\n                        hover_text.append(\"\")\n                \n                frame_traces.append(go.Bar(\n                    name=f'Anoph: {anoph_value}',\n                    x=crosstab.index,\n                    y=values,\n                    marker_color=color_dict[anoph_value],\n                    marker_line=dict(width=0.5, color='white'),\n                    hovertemplate='%{hovertext}<extra></extra>',\n                    hovertext=hover_text,\n                    opacity=0.8\n                ))\n        else:\n            # Simple bar chart for this week\n            username_counts = week_data[username_col].value_counts()\n            username_counts = username_counts.reindex(sorted(username_counts.index, key=str))\n            \n            # County mapping for this week\n            county_mapping = {}\n            if county_col:\n                for username in username_counts.index:\n                    user_counties = week_data[week_data[username_col] == username][county_col].dropna()\n                    if not user_counties.empty:\n                        county_mapping[username] = user_counties.mode().iloc[0] if len(user_counties.mode()) > 0 else user_counties.iloc[0]\n                    else:\n                        county_mapping[username] = \"Unknown\"\n            \n            hover_text = []\n            for site, count in zip(username_counts.index, username_counts.values):\n                county_name = county_mapping.get(site, \"Unknown\") if county_mapping else \"N/A\"\n                hover_text.append(\n                    f\"<b>{site}</b><br>\" +\n                    f\"Week: {week}<br>\" +\n                    f\"County: {county_name}<br>\" +\n                    f\"Total Surveys: {count}\"\n                )\n            \n            frame_traces.append(go.Bar(\n                x=username_counts.index,\n                y=username_counts.values,\n                marker_color='steelblue',\n                marker_line=dict(width=0.5, color='navy'),\n                hovertemplate='%{hovertext}<extra></extra>',\n                hovertext=hover_text,\n                opacity=0.8\n            ))\n        \n        frames.append(go.Frame(\n            data=frame_traces,\n            name=week,\n            layout=go.Layout(\n                title=f'Survey Count by Collection Site - Week {week}<br><sub>Total: {len(week_data):,} surveys</sub>'\n            )\n        ))\n    \n    # Create initial figure (first week)\n    if frames:\n        fig = go.Figure(data=frames[0].data, frames=frames)\n    else:\n        return None\n    \n    # Update layout with slider\n    total_surveys = len(df_filtered)\n    unique_sites = df_filtered[username_col].nunique()\n    unique_counties_count = len(unique_counties)\n    \n    fig.update_layout(\n        title={\n            'text': f'Survey Count by Collection Site - Interactive Timeline<br><sub>Total: {total_surveys:,} surveys from {unique_sites} sites across {unique_counties_count} counties</sub>',\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 16}\n        },\n        xaxis_title='Collection Site',\n        yaxis_title='Count of Survey',\n        barmode='stack' if anoph_col else 'group',\n        hovermode='closest',\n        width=700,\n        height=600,\n        font=dict(size=12),\n        showlegend=True if anoph_col else False,\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=1,\n            xanchor=\"left\",\n            x=1.02\n        ),\n        margin=dict(l=80, r=120, t=120, b=150),\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        updatemenus=[\n            dict(\n                type=\"buttons\",\n                direction=\"left\",\n                buttons=list([\n                    dict(\n                        args=[{\"frame\": {\"duration\": 500, \"redraw\": True},\n                               \"fromcurrent\": True, \"transition\": {\"duration\": 300}}],\n                        label=\"Play\",\n                        method=\"animate\"\n                    ),\n                    dict(\n                        args=[{\"frame\": {\"duration\": 0, \"redraw\": True},\n                               \"mode\": \"immediate\",\n                               \"transition\": {\"duration\": 0}}],\n                        label=\"Pause\",\n                        method=\"animate\"\n                    )\n                ]),\n                pad={\"r\": 10, \"t\": 87},\n                showactive=False,\n                x=0.011,\n                xanchor=\"right\",\n                y=0,\n                yanchor=\"top\"\n            ),\n        ],\n        sliders=[\n            dict(\n                active=0,\n                yanchor=\"top\",\n                xanchor=\"left\",\n                currentvalue={\n                    \"font\": {\"size\": 16},\n                    \"prefix\": \"Week: \",\n                    \"visible\": True,\n                    \"xanchor\": \"right\"\n                },\n                transition={\"duration\": 300, \"easing\": \"cubic-in-out\"},\n                pad={\"b\": 10, \"t\": 50},\n                len=0.9,\n                x=0.1,\n                y=0,\n                steps=[\n                    dict(\n                        args=[\n                            [week],\n                            {\"frame\": {\"duration\": 300, \"redraw\": True},\n                             \"mode\": \"immediate\",\n                             \"transition\": {\"duration\": 300}}\n                        ],\n                        label=week,\n                        method=\"animate\"\n                    ) for week in unique_weeks\n                ]\n            )\n        ]\n    )\n    \n    # Update axes\n    fig.update_xaxes(\n        tickangle=45,\n        tickfont=dict(size=10),\n        gridcolor='lightgray',\n        gridwidth=0.5,\n        showgrid=True\n    )\n    \n    fig.update_yaxes(\n        gridcolor='lightgray',\n        gridwidth=0.5,\n        showgrid=True,\n        zeroline=True,\n        zerolinecolor='gray',\n        zerolinewidth=1\n    )\n    \n    return fig\n\ndef main():\n    try:\n        df = load_cleaned_data()\n        if df is None:\n            return\n        \n        fig = create_interactive_time_slider_graph(df)\n        \n        if fig is not None:\n            fig.show()\n    \n    except Exception as e:\n        pass\n\nif __name__ == \"__main__\":\n    main()\n\nHow many total mosquitoes from each species?\n\n","type":"content","url":"/anostep-dashboard","position":1},{"hierarchy":{"lvl1":"AnoSTEP results so far","lvl2":"Plotting species catch by date"},"type":"lvl2","url":"/anostep-dashboard#plotting-species-catch-by-date","position":2},{"hierarchy":{"lvl1":"AnoSTEP results so far","lvl2":"Plotting species catch by date"},"content":"\n\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport numpy as np\nfrom math import cos, radians\n\n# Load both datasets with error handling\ntry:\n    df_commcare = pd.read_csv('commcare_data.csv')\n    df_priority = pd.read_csv('KenyaAdapt2025.csv')\nexcept FileNotFoundError as e:\n    print(f\"Error loading files: {e}\")\n    exit()\n\n# Rename Priority column to GP (Geographic Priority)\ndf_priority = df_priority.rename(columns={'Priority': 'GP'})\n\n# Clean the CommCare data with error handling\nrequired_columns = [\n    'gps_coordinates_latitude_(degrees)', \n    'gps_coordinates_longitude_(degrees)', \n    'type_of_breeding_site',\n    'collection_date'\n]\n\n# Check if required columns exist\nmissing_columns = [col for col in required_columns if col not in df_commcare.columns]\nif missing_columns:\n    print(f\"Missing required columns: {missing_columns}\")\n    exit()\n\n# Clean the data\ndf_clean = df_commcare.dropna(subset=required_columns)\ndf_clean = df_clean[df_clean['type_of_breeding_site'] != '---']\n\n# Create the grouped counts for CommCare data\ntry:\n    df_counts = df_clean.groupby([\n        'gps_coordinates_latitude_(degrees)', \n        'gps_coordinates_longitude_(degrees)', \n        'type_of_breeding_site', \n        'collection_date'\n    ]).agg({\n        'case_case_id': 'count',\n        'county': 'first',\n        'subcounty': 'first',\n        'geographical_information_village_name': 'first'\n    }).reset_index()\nexcept KeyError as e:\n    print(f\"Error in grouping data: {e}\")\n    exit()\n\n# Rename columns to match original structure\ndf_counts = df_counts.rename(columns={\n    'gps_coordinates_latitude_(degrees)': 'latitude',\n    'gps_coordinates_longitude_(degrees)': 'longitude', \n    'type_of_breeding_site': 'type',\n    'collection_date': 'Date',\n    'case_case_id': 'morph_id'\n})\n\n# Get unique GP values\nunique_gps = sorted(df_priority['GP'].unique())\n\n# Function to create circle coordinates for buffer zones\ndef create_circle(center_lat, center_lon, radius_km, num_points=50):\n    \"\"\"Create circle coordinates for buffer zones\"\"\"\n    try:\n        lat_radius = radius_km / 111.0\n        lon_radius = radius_km / (111.0 * cos(radians(center_lat)))\n        \n        angles = np.linspace(0, 2*np.pi, num_points)\n        circle_lats = center_lat + lat_radius * np.cos(angles)\n        circle_lons = center_lon + lon_radius * np.sin(angles)\n        \n        return circle_lats, circle_lons\n    except Exception:\n        return [], []\n\n# Calculate map center\ntry:\n    all_lats = list(df_counts['latitude']) + list(df_priority['lat'])\n    all_lons = list(df_counts['longitude']) + list(df_priority['long'])\n    center_lat = np.mean([lat for lat in all_lats if not np.isnan(lat)])\n    center_lon = np.mean([lon for lon in all_lons if not np.isnan(lon)])\nexcept Exception:\n    center_lat, center_lon = 0.5, 37.0  # Default Kenya center\n\n# Create the figure\nfig = go.Figure()\n\n# Add all breeding sites with conditional coloring based on anoph_present\nmarker_sizes = np.clip(df_counts['morph_id'] * 3, 5, 20)\n\n# Create color array based on anoph_present status\ncolors = []\nfor _, row in df_counts.iterrows():\n    # Get the original row data to check anoph_present\n    original_data = df_clean[\n        (df_clean['gps_coordinates_latitude_(degrees)'] == row['latitude']) &\n        (df_clean['gps_coordinates_longitude_(degrees)'] == row['longitude']) &\n        (df_clean['type_of_breeding_site'] == row['type']) &\n        (df_clean['collection_date'] == row['Date'])\n    ]\n    \n    if len(original_data) > 0:\n        anoph_status = original_data['anoph_present'].iloc[0]\n        if anoph_status == 'yes':\n            colors.append('rgba(50, 200, 50, 0.8)')  # Green for anoph present\n        elif anoph_status == 'no':\n            colors.append('rgba(255, 50, 50, 0.8)')  # Red for anoph not present\n        else:\n            colors.append('rgba(128, 128, 128, 0.7)')  # Gray for unknown/missing\n    else:\n        colors.append('rgba(128, 128, 128, 0.7)')  # Gray for unknown\n\nfig.add_trace(go.Scattermapbox(\n    lat=df_counts['latitude'],\n    lon=df_counts['longitude'],\n    mode='markers',\n    marker=dict(\n        size=marker_sizes,\n        sizemin=5,\n        color=colors,  # Use conditional coloring\n        opacity=0.8\n    ),\n    name='Breeding Sites',\n    text=[f\"<b>{site_type}</b><br>\" +\n          f\"Count: {count}<br>\" +\n          f\"Date: {date}<br>\" +\n          f\"Anopheles: {anoph}<br>\" +\n          f\"County: {county}<br>\" +\n          f\"Village: {village}<br>\" +\n          f\"Coords: ({lat:.4f}, {lon:.4f})\"\n          for site_type, count, date, county, village, lat, lon, anoph in \n          zip(df_counts['type'], df_counts['morph_id'], df_counts['Date'], \n              df_counts['county'].fillna('N/A'), \n              df_counts['geographical_information_village_name'].fillna('N/A'),\n              df_counts['latitude'], df_counts['longitude'],\n              [df_clean[(df_clean['gps_coordinates_latitude_(degrees)'] == row['latitude']) &\n                       (df_clean['gps_coordinates_longitude_(degrees)'] == row['longitude']) &\n                       (df_clean['type_of_breeding_site'] == row['type']) &\n                       (df_clean['collection_date'] == row['Date'])]['anoph_present'].iloc[0] \n               if len(df_clean[(df_clean['gps_coordinates_latitude_(degrees)'] == row['latitude']) &\n                              (df_clean['gps_coordinates_longitude_(degrees)'] == row['longitude']) &\n                              (df_clean['type_of_breeding_site'] == row['type']) &\n                              (df_clean['collection_date'] == row['Date'])]) > 0 else 'Unknown'\n               for _, row in df_counts.iterrows()])],\n    hovertemplate='%{text}<extra></extra>',\n    legendgroup='breeding',\n    showlegend=False\n))\n\n# Create traces for each GP individually with enhanced visibility\npriority_colors = px.colors.sequential.Plasma  # Better contrast on satellite imagery\n\n# Add traces for \"All GPs\" view (initially visible)\nfor i, gp in enumerate(unique_gps):\n    gp_data = df_priority[df_priority['GP'] == gp]\n    if len(gp_data) == 0:\n        continue\n        \n    color_idx = int(i * (len(priority_colors) - 1) / max(1, (len(unique_gps) - 1)))\n    \n    # GP points with enhanced visibility for satellite view\n    fig.add_trace(go.Scattermapbox(\n        lat=gp_data['lat'],\n        lon=gp_data['long'],\n        mode='markers',\n        marker=dict(\n            size=16,  # Larger size for better visibility\n            color=priority_colors[color_idx],  # Use the priority color directly\n            symbol='circle',  # Circle symbols for better visibility\n            opacity=1.0  # Full opacity\n        ),\n        name=f'GP {gp}',\n        text=[f\"<b>GP {gp}</b><br>\" +\n              f\"GoogleID: {gid}<br>\" +\n              f\"Coords: ({lat:.4f}, {lon:.4f})\"\n              for gid, lat, lon in \n              zip(gp_data['GoogleID'], gp_data['lat'], gp_data['long'])],\n        hovertemplate='%{text}<extra></extra>',\n        legendgroup=f'gp_{gp}',\n        visible=True,\n        showlegend=False\n    ))\n    \n    # 1km buffer for this GP with better visibility on satellite\n    for _, row in gp_data.iterrows():\n        circle_lats, circle_lons = create_circle(row['lat'], row['long'], 1)\n        if len(circle_lats) > 0:  # Only add if circle was created successfully\n            fig.add_trace(go.Scattermapbox(\n                lat=circle_lats,\n                lon=circle_lons,\n                mode='lines',\n                line=dict(width=3, color='rgba(255, 255, 0, 1.0)'),  # Yellow for visibility\n                fill='toself',\n                fillcolor='rgba(255, 255, 0, 0.15)',\n                name='1km Buffer' if i == 0 and row['GP'] == unique_gps[0] else '',\n                showlegend=True if i == 0 and row['GP'] == unique_gps[0] else False,\n                hoverinfo='skip',\n                legendgroup='buffer_1km',\n                visible=True\n            ))\n    \n    # 2km buffer for this GP with better visibility on satellite\n    for _, row in gp_data.iterrows():\n        circle_lats, circle_lons = create_circle(row['lat'], row['long'], 2)\n        if len(circle_lats) > 0:  # Only add if circle was created successfully\n            fig.add_trace(go.Scattermapbox(\n                lat=circle_lats,\n                lon=circle_lons,\n                mode='lines',\n                line=dict(width=3, color='rgba(255, 0, 255, 1.0)'),  # Magenta for visibility\n                fill='toself',\n                fillcolor='rgba(255, 0, 255, 0.15)',\n                name='2km Buffer' if i == 0 and row['GP'] == unique_gps[0] else '',\n                showlegend=True if i == 0 and row['GP'] == unique_gps[0] else False,\n                hoverinfo='skip',\n                legendgroup='buffer_2km',\n                visible=True\n            ))\n\n# Create dropdown buttons with zoom functionality\ndropdown_buttons = []\n\n# Calculate total number of traces for visibility arrays\ntotal_traces = 1  # Breeding sites\nfor gp in unique_gps:\n    gp_count = len(df_priority[df_priority['GP'] == gp])\n    total_traces += 1 + (2 * gp_count)  # GP points + buffer traces\n\n# \"All\" option - shows all GPs and resets to full view\nall_visibility = [True] * total_traces\n\ndropdown_buttons.append(\n    dict(\n        label=\"All GPs\",\n        method=\"update\",\n        args=[\n            {\"visible\": all_visibility},\n            {\n                \"mapbox.center.lat\": center_lat,\n                \"mapbox.center.lon\": center_lon,\n                \"mapbox.zoom\": 6\n            }\n        ]\n    )\n)\n\n# Individual GP options with zoom to selected location\ntrace_idx = 1  # Start after breeding sites trace\nfor target_gp in unique_gps:\n    visibility = [True]  # Breeding sites always visible\n    \n    # Get coordinates for this GP to zoom to\n    gp_coords = df_priority[df_priority['GP'] == target_gp]\n    if len(gp_coords) > 0:\n        gp_center_lat = gp_coords['lat'].mean()\n        gp_center_lon = gp_coords['long'].mean()\n    else:\n        gp_center_lat, gp_center_lon = center_lat, center_lon\n    \n    # Calculate visibility for all traces\n    current_trace_idx = 1\n    for gp in unique_gps:\n        gp_count = len(df_priority[df_priority['GP'] == gp])\n        if gp == target_gp:\n            visibility.extend([True] * (1 + 2 * gp_count))  # Show this GP + buffers\n        else:\n            visibility.extend([False] * (1 + 2 * gp_count))  # Hide other GPs + buffers\n        current_trace_idx += 1 + 2 * gp_count\n    \n    dropdown_buttons.append(\n        dict(\n            label=f\"GP {target_gp}\",\n            method=\"update\",\n            args=[\n                {\"visible\": visibility},\n                {\n                    \"mapbox.center.lat\": gp_center_lat,\n                    \"mapbox.center.lon\": gp_center_lon,\n                    \"mapbox.zoom\": 13.5  # Increased zoom to better fit 2km buffer\n                }\n            ]\n        )\n    )\n\n# Update layout with dropdown\nfig.update_layout(\n    mapbox=dict(\n        style='open-street-map',  # Changed to open-street-map (no token required)\n        center=dict(lat=center_lat, lon=center_lon),\n        zoom=6\n    ),\n    title=dict(\n        text=\"Interactive Anopheles Breeding Sites & GP Locations with Buffer Zones\",\n        x=0.5,\n        font=dict(size=16)\n    ),\n    height=700,\n    margin=dict(t=80, b=20, l=20, r=20),\n    legend=dict(\n        yanchor=\"top\",\n        y=0.99,\n        xanchor=\"right\",\n        x=0.99,\n        bgcolor=\"rgba(255,255,255,0.8)\"\n    ),\n    updatemenus=[\n        dict(\n            buttons=dropdown_buttons,\n            direction=\"down\",\n            showactive=True,\n            x=0.02,\n            xanchor=\"left\",\n            y=0.95,\n            yanchor=\"top\",\n            bgcolor=\"rgba(255,255,255,0.9)\",\n            bordercolor=\"rgba(0,0,0,0.3)\",\n            font=dict(size=12)\n        )\n    ]\n)\n\n# Add annotation for dropdown\nfig.add_annotation(\n    text=\"Select GP:\",\n    xref=\"paper\", yref=\"paper\",\n    x=0.02, y=0.97,\n    xanchor=\"left\", yanchor=\"bottom\",\n    showarrow=False,\n    font=dict(size=12, color=\"black\"),\n    bgcolor=\"rgba(255,255,255,0.8)\"\n)\n\n# Display the map\nfig.show()\n\n# # Save as HTML file\n# fig.write_html(\"interactive_commcare_gp_map.html\")\n\n","type":"content","url":"/anostep-dashboard#plotting-species-catch-by-date","position":3},{"hierarchy":{"lvl1":"AnoSTEP results so far","lvl2":"Great work team!👏 👏 👏"},"type":"lvl2","url":"/anostep-dashboard#great-work-team","position":4},{"hierarchy":{"lvl1":"AnoSTEP results so far","lvl2":"Great work team!👏 👏 👏"},"content":"","type":"content","url":"/anostep-dashboard#great-work-team","position":5},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?"},"type":"lvl1","url":"/ckmr","position":0},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?"},"content":"","type":"content","url":"/ckmr","position":1},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl2":"The Challenge: Understanding Mosquito Movement"},"type":"lvl2","url":"/ckmr#the-challenge-understanding-mosquito-movement","position":2},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl2":"The Challenge: Understanding Mosquito Movement"},"content":"One of the most significant gaps in our understanding of malaria vectors is surprisingly basic: we don’t understand well how\nfar the malaria mosquito can fly. This seemingly simple question has major implications for malaria control. Current estimates vary:\n\nTraditional studies suggest mosquitoes fly no more than 5km per generation\n\nRecent research in the \n\nSahel and western Kenya indicates mosquitoes may travel much further, carried by wind currents over extremely large distances","type":"content","url":"/ckmr#the-challenge-understanding-mosquito-movement","position":3},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl3":"Why This Matters","lvl2":"The Challenge: Understanding Mosquito Movement"},"type":"lvl3","url":"/ckmr#why-this-matters","position":4},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl3":"Why This Matters","lvl2":"The Challenge: Understanding Mosquito Movement"},"content":"Understanding mosquito dispersal is crucial for several reasons:\n\nVector Control Trials: To effectively evaluate new control tools like spatial repellents and ATSBs, we need to design robust randomized controlled trials (RCTs). The distance mosquitoes can travel affects how we structure these trials.\n\nGene Drive Implementation: Gene drive technology shows promise for malaria control through either:\n\nPopulation suppression\n\nMaking vectors refractory to malaria transmission\n\nLarge consortiums like Target Malaria and Zero Transmission are planning field trials in the near future. To model gene drive spread accurately, we must understand mosquito movement patterns.\n\nInsecticide Resistance: The spread of insecticide resistance threatens current control methods, which are heavily reliant on insecticide use. Understanding how mosquitoes move helps us track and predict resistance spread.","type":"content","url":"/ckmr#why-this-matters","position":5},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl2":"Close-Kin Mark-Recapture (CKMR)"},"type":"lvl2","url":"/ckmr#close-kin-mark-recapture-ckmr","position":6},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl2":"Close-Kin Mark-Recapture (CKMR)"},"content":"","type":"content","url":"/ckmr#close-kin-mark-recapture-ckmr","position":7},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl3":"What is CKMR?","lvl2":"Close-Kin Mark-Recapture (CKMR)"},"type":"lvl3","url":"/ckmr#what-is-ckmr","position":8},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl3":"What is CKMR?","lvl2":"Close-Kin Mark-Recapture (CKMR)"},"content":"Close-kin mark-recapture is an advanced genomic technique that allows us estimate demographic parameters, such as dispersal rates and population size. It was originally developed for fisheries \n\n(Bravington et al.  2016). Instead of marking and releasing individual organisms, we:\n\nSample mosquitoes across a defined area\n\nSequence their genomes\n\nIdentify related individuals through their DNA\n\nUse the geographic distance between related mosquitoes to estimate dispersal patterns","type":"content","url":"/ckmr#what-is-ckmr","position":9},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl3":"Why CKMR?","lvl2":"Close-Kin Mark-Recapture (CKMR)"},"type":"lvl3","url":"/ckmr#why-ckmr","position":10},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl3":"Why CKMR?","lvl2":"Close-Kin Mark-Recapture (CKMR)"},"content":"CKMR offers several advantages over traditional methods:\n\nNon-invasive: No need to mark mosquitoes, which can affect their behavior\n\nComprehensive: Can detect both short and long-distance movement\n\nAdditional insights: Beyond dispersal, CKMR can reveal:\n\nCensus population size\n\nDaily survivorship\n\nPopulation dynamics\n\nWhilst genomics is revolutionising vector surveillance, most advances have focused on monitoring insecticide resistance. AnoKin utilises genomics in a novel, innovative way to estimate dispersal rates.","type":"content","url":"/ckmr#why-ckmr","position":11},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl2":"Project Implementation"},"type":"lvl2","url":"/ckmr#project-implementation","position":12},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl2":"Project Implementation"},"content":"","type":"content","url":"/ckmr#project-implementation","position":13},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl3":"Study Site","lvl2":"Project Implementation"},"type":"lvl3","url":"/ckmr#study-site","position":14},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl3":"Study Site","lvl2":"Project Implementation"},"content":"We are conducting this work at Lake Kanyaboli, western Kenya, chosen for:\n\nHigh malaria transmission\n\nStable An. funestus habitat\n\nExisting research infrastructure\n\nWell-characterized wind patterns","type":"content","url":"/ckmr#study-site","position":15},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl3":"Expected Outcomes","lvl2":"Project Implementation"},"type":"lvl3","url":"/ckmr#expected-outcomes","position":16},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl3":"Expected Outcomes","lvl2":"Project Implementation"},"content":"In conducting this project, we hope to provide:\n\nQuantitative estimates of An. funestus dispersal distances and rates\n\nOpen-source software for analyzing close-kin genomic data\n\nImproved design parameters for future intervention trials","type":"content","url":"/ckmr#expected-outcomes","position":17},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl2":"Looking Forward"},"type":"lvl2","url":"/ckmr#looking-forward","position":18},{"hierarchy":{"lvl1":"Anopheles stephensi Dashboard?","lvl2":"Looking Forward"},"content":"The results from AnoKin will directly inform:\n\nDesign of vector control trials\n\nImplementation of gene drive strategies\n\nManagement of insecticide resistance\n\nBy filling this critical knowledge gap, we can better target our interventions and work more effectively toward malaria elimination.","type":"content","url":"/ckmr#looking-forward","position":19}]}